#!/usr/bin/env python
# -*- coding: iso-8859-15 -*-
# generated by wxGlade 0.6.5 (standalone edition) on Mon Feb 13 13:09:57 2012

import os
import sys
import collections
import time
import math
import wx
import threading
import socket
import struct
import copy
import random
import re
import winsound
import pyttsx
import lib.fileMethods as fileMethods

# begin wxGlade: extracode
# end wxGlade

class regionEditor(wx.Frame):
    def __init__(self, *args, **kwds):
        # begin wxGlade: regionEditor.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        
        # Menu Bar
        self.RegionEditor_menubar = wx.MenuBar()
        self.filemenu = wx.Menu()
        self.menuNew = wx.MenuItem(self.filemenu, wx.NewId(), "New", "", wx.ITEM_NORMAL)
        self.filemenu.AppendItem(self.menuNew)
        self.menuOpen = wx.MenuItem(self.filemenu, wx.NewId(), "Open", "", wx.ITEM_NORMAL)
        self.filemenu.AppendItem(self.menuOpen)
        self.menuSave = wx.MenuItem(self.filemenu, wx.NewId(), "Save", "", wx.ITEM_NORMAL)
        self.filemenu.AppendItem(self.menuSave)
        self.menuSaveAs = wx.MenuItem(self.filemenu, wx.NewId(), "Save As", "", wx.ITEM_NORMAL)
        self.filemenu.AppendItem(self.menuSaveAs)
        self.menuExit = wx.MenuItem(self.filemenu, wx.NewId(), "Exit", "", wx.ITEM_NORMAL)
        self.filemenu.AppendItem(self.menuExit)
        self.RegionEditor_menubar.Append(self.filemenu, "File")
        self.menuEdit = wx.Menu()
        self.menuUndo = wx.MenuItem(self.menuEdit, wx.NewId(), "Undo", "", wx.ITEM_NORMAL)
        self.menuEdit.AppendItem(self.menuUndo)
        self.menuRedo = wx.MenuItem(self.menuEdit, wx.NewId(), "Redo", "", wx.ITEM_NORMAL)
        self.menuEdit.AppendItem(self.menuRedo)
        self.RegionEditor_menubar.Append(self.menuEdit, "Edit")
        self.menuDrawing = wx.Menu()
        self.menuAutobound = wx.MenuItem(self.menuDrawing, wx.NewId(), "Autoboundary", "", wx.ITEM_NORMAL)
        self.menuDrawing.AppendItem(self.menuAutobound)
        self.menuRect = wx.MenuItem(self.menuDrawing, wx.NewId(), "Rectangle", "", wx.ITEM_NORMAL)
        self.menuDrawing.AppendItem(self.menuRect)
        self.menuPoly = wx.MenuItem(self.menuDrawing, wx.NewId(), "Polygon", "", wx.ITEM_NORMAL)
        self.menuDrawing.AppendItem(self.menuPoly)
        self.menuAddPoint = wx.MenuItem(self.menuDrawing, wx.NewId(), "Add Point", "", wx.ITEM_NORMAL)
        self.menuDrawing.AppendItem(self.menuAddPoint)
        self.menuRemPoint = wx.MenuItem(self.menuDrawing, wx.NewId(), "Remove Point", "", wx.ITEM_NORMAL)
        self.menuDrawing.AppendItem(self.menuRemPoint)
        self.RegionEditor_menubar.Append(self.menuDrawing, "Drawing")
        self.menuView = wx.Menu()
        self.menuMarkers = wx.MenuItem(self.menuView, wx.NewId(), "Markers", "", wx.ITEM_CHECK)
        self.menuView.AppendItem(self.menuMarkers)
        self.menuMarkersClear = wx.MenuItem(self.menuView, wx.NewId(), "Clear Markers", "", wx.ITEM_NORMAL)
        self.menuView.AppendItem(self.menuMarkersClear)
        self.menuCamera = wx.MenuItem(self.menuView, wx.NewId(), "Camera Capture", "", wx.ITEM_NORMAL)
        self.menuView.AppendItem(self.menuCamera)
        self.menuImageImport = wx.MenuItem(self.menuView, wx.NewId(), "Import Background Image", "", wx.ITEM_NORMAL)
        self.menuView.AppendItem(self.menuImageImport)
        self.menuImageClear = wx.MenuItem(self.menuView, wx.NewId(), "Clear Background Image", "", wx.ITEM_NORMAL)
        self.menuView.AppendItem(self.menuImageClear)
        self.RegionEditor_menubar.Append(self.menuView, "View")
        self.helpmenu = wx.Menu()
        self.menuAbout = wx.MenuItem(self.helpmenu, wx.NewId(), "About", "", wx.ITEM_NORMAL)
        self.helpmenu.AppendItem(self.menuAbout)
        self.RegionEditor_menubar.Append(self.helpmenu, "Help")
        self.SetMenuBar(self.RegionEditor_menubar)
        # Menu Bar end
        self.sidebar = wx.Panel(self, -1)
        self.toggleVicon = wx.ToggleButton(self.sidebar, -1, "Vicon")
        self.buttonCamera = wx.Button(self.sidebar, -1, "Camera")
        self.toggleSquare = wx.ToggleButton(self.sidebar, -1, "Rect.")
        self.togglePoly = wx.ToggleButton(self.sidebar, -1, "Polygon")
        self.toggleDim = wx.ToggleButton(self.sidebar, -1, "Length")
        self.toggleFeedback = wx.ToggleButton(self.sidebar, -1, "Feedback")
        self.buttonCal = wx.Button(self.sidebar, -1, "Calibrate")
        self.canvas = wx.Panel(self, -1, style=wx.SUNKEN_BORDER | wx.TAB_TRAVERSAL)

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_MENU, self.OnMenuNew, self.menuNew)
        self.Bind(wx.EVT_MENU, self.OnMenuOpen, self.menuOpen)
        self.Bind(wx.EVT_MENU, self.OnMenuSave, self.menuSave)
        self.Bind(wx.EVT_MENU, self.OnMenuSaveAs, self.menuSaveAs)
        self.Bind(wx.EVT_MENU, self.OnMenuExit, self.menuExit)
        self.Bind(wx.EVT_MENU, self.OnMenuUndo, self.menuUndo)
        self.Bind(wx.EVT_MENU, self.OnMenuRedo, self.menuRedo)
        self.Bind(wx.EVT_MENU, self.OnMenuAutobound, self.menuAutobound)
        self.Bind(wx.EVT_MENU, self.OnMenuRect, self.menuRect)
        self.Bind(wx.EVT_MENU, self.OnMenuPoly, self.menuPoly)
        self.Bind(wx.EVT_MENU, self.OnMenuAddPoint, self.menuAddPoint)
        self.Bind(wx.EVT_MENU, self.OnMenuRemPoint, self.menuRemPoint)
        self.Bind(wx.EVT_MENU, self.OnMenuMarkers, self.menuMarkers)
        self.Bind(wx.EVT_MENU, self.OnMenuMarkersClear, self.menuMarkersClear)
        self.Bind(wx.EVT_MENU, self.OnMenuCamera, self.menuCamera)
        self.Bind(wx.EVT_MENU, self.OnMenuImageImport, self.menuImageImport)
        self.Bind(wx.EVT_MENU, self.OnMenuImageClear, self.menuImageClear)
        self.Bind(wx.EVT_MENU, self.OnMenuAbout, self.menuAbout)
        self.Bind(wx.EVT_TOGGLEBUTTON, self.OnToggleVicon, self.toggleVicon)
        self.Bind(wx.EVT_BUTTON, self.OnButtonCamera, self.buttonCamera)
        self.Bind(wx.EVT_TOGGLEBUTTON, self.OnToggleSquare, self.toggleSquare)
        self.Bind(wx.EVT_TOGGLEBUTTON, self.OnTogglePoly, self.togglePoly)
        self.Bind(wx.EVT_TOGGLEBUTTON, self.OnToggleDim, self.toggleDim)
        self.Bind(wx.EVT_TOGGLEBUTTON, self.OnToggleFeedback, self.toggleFeedback)
        self.Bind(wx.EVT_BUTTON, self.OnButtonCal, self.buttonCal)
        # end wxGlade
        
        # Handle input
        if len(args) > 2 and isinstance(args[2], str):
            self.fileName = os.path.join(os.getcwd(), args[2])
        else:
            self.fileName = ""
        
        # Bind mouse events
        self.canvas.Bind(wx.EVT_LEFT_DOWN, self.OnMouseLeftDown, self.canvas)
        self.canvas.Bind(wx.EVT_LEFT_UP, self.OnMouseLeftUp, self.canvas)
        self.canvas.Bind(wx.EVT_LEFT_DCLICK, self.OnMouseLeftDClick, self.canvas)
        self.canvas.Bind(wx.EVT_RIGHT_DOWN, self.OnMouseRightDown, self.canvas)
        self.canvas.Bind(wx.EVT_RIGHT_UP, self.OnMouseRightUp, self.canvas)
        self.canvas.Bind(wx.EVT_MOUSEWHEEL, self.OnMouseWheel, self.canvas)
        self.canvas.Bind(wx.EVT_ENTER_WINDOW, self.OnEnterWindow, self.canvas)
        self.canvas.Bind(wx.EVT_LEAVE_WINDOW, self.OnLeaveWindow, self.canvas)
        
        # Bind keyboard events
        self.Bind(wx.EVT_KEY_DOWN, self.OnKeyDown, self)
        self.canvas.Bind(wx.EVT_KEY_DOWN, self.OnKeyDown, self.canvas)
        
        # Determine mapping of the canvas panel to the field
        canvasLen = self.canvas.GetSize()       # Initial size of canvas (pixels)
        fieldRange = [(-3.0, 9.0), (-3.0, 3.0)] # Initial range of field (m)
                                                # [(xmin, xmax), (ymin, ymax)]
        # pose = pixPose * scale + offset
        # Note: y-pixels and y-pose have opposite directions
        xScale = (fieldRange[0][1] - fieldRange[0][0]) / float(canvasLen[0])
        xOffset = fieldRange[0][0]
        yScale = -(fieldRange[1][1] - fieldRange[1][0]) / float(canvasLen[1])
        yOffset = -fieldRange[1][0]
        self.canvasScale = Point(xScale, yScale)
        self.canvasOffset = Point(xOffset, yOffset)
        
        # Region-related parameters
        self.regions = []                   # List of regions in the map
        self.adjacent = []                  # List of lists holding transition
                                            # edges between regions.
                                            # adjacent[i][j] contains a list of
                                            # indices of edges in region i that
                                            # connect to edges in region j.
                                            # adjacent[j][i] should contain a
                                            # list of the same length, but edge
                                            # indices are for region j.
                                            # adjacent[i][i] will be empty.
        self.polyVerts = []                 # Keeps points for region creation
                                            # and dimensioning
                                            # Region creation: [Point(x0,y0), ...]
                                            # Dimensioning: (idxRegion, idxVert)
        self.polySnaps = []                 # Keeps snap information for each
                                            # new region creation point
                                            # [(idxReg, idxPt, idxEdge), ...]
        self.boundary = None                # Region representing the map bound
        # TODO: When changing the name of a region, check if it is called boundary
        
        # Mouse-related parameters
        self.leftClickPt = Point(0.0, 0.0)  # Location of last left downclick
        self.rightClickPt = Point(0.0, 0.0) # Location of last right downclick
        self.justDoubleClicked = False      # Indicating double-click event
        self.tolerance = 5.0 * xScale       # Distance to consider as "same point" (m)
        self.selectedRegions = []           # List of currently selected regions
        
        # Set up for undo/redo capabilities
        # TODO: Disable self.menuUndo and self.menuRedo
        self.unredoBufLen = 50
        self.undoActions = collections.deque()
        self.redoActions = collections.deque()
        
        # Add paint event handler to draw on the canvas
        self.Bind(wx.EVT_PAINT, self.OnCanvasPaint, self.canvas)
        
        # Create Vicon listener
        self.markerPoses = []   # Marker positions to be drawn
        self.viconListener = ViconMarkerListener(self)
        self.dlgFeedback = None
        
        # Add close event handler to cleanup and possibly save before closing
        self.Bind(wx.EVT_CLOSE, self.OnClose)
        
        # Display the GUI window and set up the map canvas
        self.Show()
        self.DrawGrid()
    
    def __set_properties(self):
        # begin wxGlade: regionEditor.__set_properties
        self.SetTitle("Region Editor")
        self.toggleVicon.SetMinSize((50, 50))
        self.buttonCamera.SetMinSize((50, 50))
        self.toggleSquare.SetMinSize((50, 50))
        self.togglePoly.SetMinSize((50, 50))
        self.toggleDim.SetMinSize((50, 50))
        self.toggleFeedback.SetMinSize((50, 50))
        self.buttonCal.SetMinSize((50, 50))
        self.sidebar.SetMinSize((150, 400))
        self.canvas.SetMinSize((800, 400))
        self.canvas.SetBackgroundColour(wx.Colour(255, 255, 255))
        # end wxGlade
    
    def __do_layout(self):
        # begin wxGlade: regionEditor.__do_layout
        sizer_1 = wx.BoxSizer(wx.HORIZONTAL)
        grid_sizer_1 = wx.GridSizer(4, 2, 5, 5)
        grid_sizer_1.Add(self.toggleVicon, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        grid_sizer_1.Add(self.buttonCamera, 1, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        grid_sizer_1.Add(self.toggleSquare, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        grid_sizer_1.Add(self.togglePoly, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        grid_sizer_1.Add(self.toggleDim, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        grid_sizer_1.Add(self.toggleFeedback, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        grid_sizer_1.Add(self.buttonCal, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        self.sidebar.SetSizer(grid_sizer_1)
        sizer_1.Add(self.sidebar, 0, wx.EXPAND, 0)
        sizer_1.Add(self.canvas, 1, wx.EXPAND, 0)
        self.SetSizer(sizer_1)
        sizer_1.Fit(self)
        self.Layout()
        # end wxGlade
    
    def OnClose(self, event):
        """Perform cleanup tasks and close the application."""
        # Check if the closure can even be canceled
        # TODO: Check if map is unsaved and ask if they want to save before closing
        if not event or event.CanVeto():
            dlg = wx.MessageDialog(self,
                "Do you really want to close this application?",
                "Confirm Exit", wx.OK|wx.CANCEL|wx.ICON_QUESTION)
            result = dlg.ShowModal()
            dlg.Destroy()
            if result == wx.ID_OK:
                self.viconListener.stop()
                # TODO: Check if vicon is indeed running, and put wait-notify
                #       in to close port before closing GUI
                self.Destroy()
        else:
            self.viconListener.stop()
            self.Destroy()

    def OnToggleVicon(self, event):  # wxGlade: regionEditor.<event_handler>
        # Switch Vicon streaming on or off based on state of toggle button
        if self.toggleVicon.GetValue():
            self.viconListener.start()
            
            # TODO: Add while loop to wait for data to come in
            #       If it times out print message
            #       If data comes in, zoom out to ensure all markers seen
        else:
            self.viconListener.stop()
            # Reinitialize thread to enable restarting it
            self.viconListener = ViconMarkerListener(self)

    def OnButtonCamera(self, event):  # wxGlade: regionEditor.<event_handler>
        print "Camera not yet implemented"
        # TODO
        event.Skip()

    def OnToggleSquare(self, event):  # wxGlade: regionEditor.<event_handler>
        self.ResetMapToggles(self.toggleSquare)

    def OnTogglePoly(self, event):  # wxGlade: regionEditor.<event_handler>
        self.ResetMapToggles(self.togglePoly)

    def OnToggleDim(self, event):  # wxGlade: regionEditor.<event_handler>
        self.ResetMapToggles(self.toggleDim)

    def OnToggleFeedback(self, event):  # wxGlade: regionEditor.<event_handler>
        self.ResetMapToggles(self.toggleFeedback)
        if self.toggleFeedback.GetValue():
            self.dlgFeedback = FeedbackDialog(self)
            self.dlgFeedback.ShowModal()
        elif self.dlgFeedback:
            self.dlgFeedback.OnClose(None)

    def OnButtonCal(self, event):  # wxGlade: regionEditor.<event_handler>
        # TODO
        print "Calibration not yet implemented"
        self.ResetMapToggles()
    
    def OnMenuNew(self, event):  # wxGlade: regionEditor.<event_handler>
        print "Event handler `OnMenuNew' not implemented"
        event.Skip()
    
    def OnMenuOpen(self, event):  # wxGlade: regionEditor.<event_handler>
        # Start up save dialog
        dialogOpen = wx.FileDialog(self, message="Open File", \
            defaultDir=sys.path[0], \
            defaultFile=self.fileName.split('\\').pop(), \
            wildcard="*.regions", style=wx.FD_OPEN)
        
        # Hit Open
        if dialogOpen.ShowModal() == wx.ID_OK:
            filePath = dialogOpen.GetPath()
            if not os.path.exists(filePath) or not ('.regions' in filePath):
                return
            
            # Pull all data from file into dictionary for parsing
            data = fileMethods.readFromFile(filePath)
            
            if data is None:
                return
            
            # Clear all current information
            self.regions = []
            self.adjacent = []
            # self.bkgndImage = None
            
            # TODO: Uncomment when background image is included
            #try:
            #    self.bkgndImage = data["Background"][0]
            #except KeyError:
            #    self.bkgndImage = None
            
            # Set all region information from lines in file
            # Each region line format is this:
            #   Name {ColorR ColorG ColorB} [(x1 y1) (x2 y2) ...]
            for rData in data["Regions"]:
                rData = re.sub('[\[\]\(\)\{\}]', '', rData)
                rData = rData.split()       # Separates on any whitespace
                rName = rData[0]
                rRGB = []
                for i in range(1, 4):       # Convert colors to integers
                    rRGB.append(int(rData[i]))
                rVerts = []
                for i in range(4, len(rData), 2):
                    x = float(rData[i])
                    y = float(rData[i+1])
                    rVerts.append(Point(x, y))
                region = Region(rVerts, rName, rgb=rRGB)
                self.regions.append(region)

            # Make an empty adjacency matrix of size (nRegions) x (nRegions)
            self.adjacent = [[[] for j in range(len(self.regions))] \
                for i in range(len(self.regions))]
            
            # Assign region transitions
            # Each transition line format is this:
            # Region1Idx Region2Idx [(Reg1FaceIdx1 Reg2FaceIdx1) (Reg1FaceIdx2 Reg2FaceIdx2) ...]
            for tData in data["Transitions"]:
                tData = re.sub('[\[\]\(\)]', '', tData)
                tData = tData.split();      # Separate on any whitespace
                iReg1 = int(tData[0])
                iReg2 = int(tData[1])
                faces = []
                # All transitions between regions
                for i in range(2, len(transData), 2):
                    iFaceReg1 = int(tData[i])
                    iFaceReg2 = int(tData[i+1])
                    self.adjacent[iReg1][iReg2].append((iFaceReg1, iFaceReg2))
                    # Note that region file specifies transitions in both directions
                    # So mirroring here is unnecessary
                    
            # Set "obstacleness" of regions
            if "Obstacles" in data:
                for iReg in data["Obstacles"]:
                    self.regions[iReg].isObstacle = True
            
            # Store the filename for saving
            self.fileName = filePath
        
        # TODO: Rescale/pan map to bring full map into view
        self.RedrawCanvas()
        
        dialogOpen.Destroy()
    
    def OnMenuSave(self, event):  # wxGlade: regionEditor.<event_handler>
        """Save to file that has already been used."""
        if self.fileName:
            f = open(self.fileName, 'w')
            f.write("# This is a region definition file for the LTLMoP " + \
                "toolkit.\n# Format details are described at the " + \
                "beginning of each section below.\n# Note that all values " + \
                "are separated by *whitespace*.\n\nBackground: # Relative " + \
                "path of background image file\n")
            f.write("None\n\n")     # TODO: Support for background images
            f.write("Obstacles: # Indices of regions to treat as obstacles\n")
            f.write("\n\n")         # TODO: Support for obstacles
            f.write("Regions: # Name {ColorR ColorG ColorB} " + \
                "[(x1 y1) (x2 y2) ...]\n")
            if not self.boundary:
                self.Autoboundary()
            if self.boundary:       # Check in case there were no regions
                f.write(str(self.boundary) + "\n")
            for reg in self.regions:
                f.write(str(reg) + "\n")
            f.write("\n")
            f.write("Transitions: # Region1Idx Region2Idx " + \
                "[(Reg1FaceIdx1 Reg2FaceIdx1) (Reg1FaceIdx2 Reg2FaceIdx2) " + \
                "...]\n")
            for iAdj in range(len(self.adjacent)):
                for jAdj, adjList in enumerate(self.adjacent[iAdj]):
                    if iAdj != jAdj and adjList:
                        line = "%d\t%d\t[" % (iAdj, jAdj)
                        for kAdj, adj in enumerate(adjList):
                            line += "(%d\t%d)" % adj
                            if kAdj < len(adjList) - 1:
                                line += "\t"
                        line += "]\n"
                        f.write(line)
            f.close()
        else:
            self.OnMenuSaveAs(None)
    
    def OnMenuSaveAs(self, event):  # wxGlade: regionEditor.<event_handler>
        dialogSave = wx.FileDialog(self, message="Save File As", \
            defaultDir=sys.path[0], \
            defaultFile=self.fileName.split('\\').pop(), \
            wildcard="*.regions", style=wx.FD_SAVE|wx.FD_OVERWRITE_PROMPT)
        # Hit Save and confirmed overwrite if necessary
        if dialogSave.ShowModal() == wx.ID_OK:
            self.fileName = dialogSave.GetPath()
            self.OnMenuSave(None)
        dialogSave.Destroy()

    def OnMenuExit(self, event):  # wxGlade: regionEditor.<event_handler>
        self.OnClose(None)

    def OnMenuUndo(self, event):  # wxGlade: regionEditor.<event_handler>
        """Revert the most recent undoable change."""
        # Currently drawing polygon
        # Note that this is not a redoable action by design
        if self.polyVerts:
            self.polyVerts = []
            self.polySnaps = []
            self.RedrawCanvas()
        # Other undoable changes exist
        elif self.undoActions:
            action = self.undoActions.pop()
            # Creation action
            if not action.oldState:
                # Single region creation
                if isinstance(action.newState, Region):
                    self.regions.remove(action.newState)
                # Map load from blank canvas
                if isinstance(action.newState, list):
                    self.regions = []
                # TODO: Background image load from blank
            # Deletion action
            if not action.newState:
                # Single region deletion
                if isinstance(action.oldState, Region):
                    self.regions.append(action.oldState)
                # Multiple region deletion or map clear
                if isinstance(action.oldState, list):
                    self.regions.extend(action.oldState)
                # TODO: Background image clear
            # Modification action
            else:
                # Single region modification
                if isinstance(action.oldState, Region):
                    idx = self.regions.index(action.newState)
                    self.regions[idx] = action.oldState
                # Map load from non-blank canvas
                if isinstance(action.oldState, list):
                    self.regions = action.oldState
                # TODO: Background image load from other image
            self.redoActions.append(action)
            # TODO: if not self.undoActions: disable self.menuUndo
            # TODO: enable self.menuRedo
            self.RedrawCanvas()

    def OnMenuRedo(self, event):  # wxGlade: regionEditor.<event_handler>
        """Reapply most recently undone action."""
        # Redoable actions exist
        if self.redoActions:
            action = self.redoActions.pop()
            # Creation action
            if not action.oldState:
                # Single region creation
                if isinstance(action.newState, Region):
                    self.regions.append(action.newState)
                # Map load from blank canvas
                if isinstance(action.newState, list):
                    self.regions = action.newState
                # TODO: Background image load from blank
            # Deletion action
            if not action.newState:
                # Single region deletion
                if isinstance(action.oldState, Region):
                    self.regions.remove(action.oldState)
                # Multiple region deletion or map clear
                if isinstance(action.oldState, list):
                    for reg in action.oldState:
                        self.regions.remove(reg)
                # TODO: Background image clear
            # Modification action
            else:
                # Single region modification
                if isinstance(action.oldState, Region):
                    idx = self.regions.index(action.oldState)
                    self.regions[idx] = action.newState
                # Map load from non-blank canvas
                if isinstance(action.oldState, list):
                    self.regions = action.newState
                # TODO: Background image load from other image
            self.undoActions.append(action)
            # TODO: if not self.redoActions: disable self.menuRedo
            # TODO: enable self.menuUndo
            self.RedrawCanvas()

    def OnMenuAutobound(self, event):  # wxGlade: regionEditor.<event_handler>
        print "Event handler `OnMenuAutobound' not implemented"
        event.Skip()

    def OnMenuRect(self, event):  # wxGlade: regionEditor.<event_handler>
        print "Event handler `OnMenuRect' not implemented"
        event.Skip()

    def OnMenuPoly(self, event):  # wxGlade: regionEditor.<event_handler>
        print "Event handler `OnMenuPoly' not implemented"
        event.Skip()

    def OnMenuAddPoint(self, event):  # wxGlade: regionEditor.<event_handler>
        print "Event handler `OnMenuAddPoint' not implemented"
        event.Skip()

    def OnMenuRemPoint(self, event):  # wxGlade: regionEditor.<event_handler>
        print "Event handler `OnMenuRemPoint' not implemented"
        event.Skip()

    def OnMenuMarkers(self, event):  # wxGlade: regionEditor.<event_handler>
        print "Event handler `OnMenuMarkers' not implemented"
        event.Skip()

    def OnMenuMarkersClear(self, event):  # wxGlade: regionEditor.<event_handler>
        print "Event handler `OnMenuMarkersClear' not implemented"
        event.Skip()

    def OnMenuCamera(self, event):  # wxGlade: regionEditor.<event_handler>
        print "Event handler `OnMenuCamera' not implemented"
        event.Skip()

    def OnMenuImageImport(self, event):  # wxGlade: regionEditor.<event_handler>
        print "Event handler `OnMenuImageImport' not implemented"
        event.Skip()

    def OnMenuImageClear(self, event):  # wxGlade: regionEditor.<event_handler>
        print "Event handler `OnMenuImageClear' not implemented"
        event.Skip()
    
    def OnMenuAbout(self, event):  # wxGlade: regionEditor.<event_handler>
        print "About not yet implemented"
        event.Skip()

    def OnMouseLeftDown(self, event):
        """Save the left click point so it can be used later."""
        self.leftClickPt, iReg, iPt, iEd = \
            self.SnapPoint(self.Pix2Map(event.GetPosition()))

    def OnMouseLeftUp(self, event):
        """Perform appropriate action based on current mode of operation."""
        # Get click position
        ptPix = event.GetPosition()
        pt, iReg, iPt, iEd = self.SnapPoint(self.Pix2Map(ptPix))
        
        # Has been handled by double-click event handler
        if self.justDoubleClicked:
            self.justDoubleClicked = False      # Reset flag
        
        # Creating a rectangular region
        elif self.toggleSquare.GetValue():
            # Making the second corner of rectangle
            if self.polyVerts:
                # Snap vertices to regions as necessary, not to Vicon
                # This may result in a non-square region, but may be preferable
                x0 = self.polyVerts[0].x
                y0 = self.polyVerts[0].y
                pt1, iReg1, iPt1, iEd1, snapped1 = \
                    self.SnapRegions(Point(x0, pt.y))
                pt3, iReg3, iPt3, iEd3, snapped3 = \
                    self.SnapRegions(Point(pt.x, y0))
                # Move clicked points if other vertices snap and they don't
                if snapped1:
                    if iReg == -1:
                        pt = Point(pt.x, pt1.y)
                    if self.polySnaps[0][0] == -1:
                        self.polyVerts[0] = Point(pt1.x, self.polyVerts[0].y)
                if snapped3:
                    if iReg == -1:
                        pt = Point(pt3.x, pt.y)
                    if self.polySnaps[0][0] == -1:
                        self.polyVerts[0] = Point(self.polyVerts[0].x, pt3.y)
                self.polyVerts.append(pt1)
                self.polyVerts.append(pt)
                self.polyVerts.append(pt3)
                self.polySnaps.append((iReg1, iPt1, iEd1))
                self.polySnaps.append((iReg, iPt, iEd))
                self.polySnaps.append((iReg3, iPt3, iEd3))
                # Create a square between previous click and new click
                self.CreateRegion()
            # Making the first corner of rectangle
            else:
                # Save point as first corner of square
                self.polyVerts.append(pt)
                self.polySnaps.append((iReg, iPt, iEd))

        # Creating a polygonal region
        elif self.togglePoly.GetValue():
            # Closing the polygon to create a region
            if self.polyVerts and len(self.polyVerts) > 2 and \
                    pt == self.polyVerts[0]:
                self.CreateRegion()
            # New point distinct from others
            elif not pt in self.polyVerts:
                self.polyVerts.append(pt)
                self.polySnaps.append((iReg, iPt, iEd))
                # Plot line between last two points
                if len(self.polyVerts) > 1:
                    x1pix, y1pix = self.Map2Pix(self.polyVerts[-2])
                    x2pix, y2pix = self.Map2Pix(pt)
                    dc = wx.WindowDC(self.canvas)
                    dc.DrawLine(x1pix, y1pix, x2pix, y2pix)

        # Dimensioning region edge
        elif self.toggleDim.GetValue():
            # First point on region to be clicked
            if not self.polyVerts and iReg != -1 and iPt != -1:
                # Store region and point indeces
                self.polyVerts = (iReg, iPt)
            # Second unique point to be clicked
            elif iReg != -1 and iPt != -1 and (iReg, iPt) != self.polyVerts:
                # Request dimension
                currDist = self.regions[iReg].verts[iPt].Dist(self.regions[\
                    self.polyVerts[0]].verts[self.polyVerts[1]])
                dimDlg = wx.TextEntryDialog(self, \
                    "Current Length: %.3f" % currDist, caption='Dimension')
                if dimDlg.ShowModal() == wx.ID_OK:
                    # Check for valid dimension (allow negative values)
                    try:
                        dim = float(dimDlg.GetValue())
                    except ValueError:
                        dimDlg.Destroy()
                        return
                    dimDlg.Destroy()

                    # Move second point along same line to specified distance
                    oldRegion = copy.deepcopy(self.regions[iReg])
                    pt0 = self.regions[self.polyVerts[0]].verts[self.polyVerts[1]]
                    signx = 1.0
                    signy = 1.0
                    # Vertical line case
                    if pt0.x == pt.x:
                        if pt0.y > pt.y:
                            signy = -1.0
                        dx = 0.0
                        dy = signy * (dim - pt.Dist(pt0))
                    # Horizontal and normal line cases
                    else:
                        if pt0.x > pt.x:
                            signx = -1.0
                        if pt0.y > pt.y:
                            signy = -1.0
                        slope = (pt.y - pt0.y) / (pt.x - pt0.x)
                        dx = signx * (dim - pt.Dist(pt0)) / \
                            math.sqrt(1 + slope ** 2)
                        dy = slope * dx
                    self.regions[iReg].verts[iPt] = \
                        self.regions[iReg].verts[iPt] + Point(dx, dy)
                    self.AddToUndo(Action(oldRegion, self.regions[iReg]))
                    self.polyVerts = []
                    self.RedrawCanvas()
        
        # Dragging region(s) or vertices
        elif self.selectedRegions and \
                pt.Dist(self.leftClickPt) > self.tolerance:
            self.leftClickPt, iReg, iPt, iEd, snapped = \
                self.SnapRegions(self.leftClickPt)
            iRegInner = self.InsideRegions(self.leftClickPt)
            
            # Dragging point(s)
            if iReg in self.selectedRegions and iPt != -1:
                # Change point position and check adjacencies
                self.regions[iReg].verts[iPt].Set(pt.x, pt.y)
                self.RecalcAdjacency(iReg)
                self.RedrawCanvas()
            
            # Dragging region(s)
            elif iReg in self.selectedRegions or \
                    iRegInner in self.selectedRegions:
                # Change region(s) position and check adjacencies
                delta = pt - self.leftClickPt
                for iRegSel in self.selectedRegions:
                    for iPt in range(len(self.regions[iRegSel].verts)):
                        self.regions[iRegSel].verts[iPt] += delta
                for iRegSel in self.selectedRegions:
                    self.RecalcAdjacency(iRegSel)
                self.RedrawCanvas()
        
        # Panning the map view
        elif pt.Dist(self.leftClickPt) > self.tolerance:
            downClickPix = self.Map2Pix(self.leftClickPt)
            self.canvasOffset = Point(self.canvasScale.x * \
                (downClickPix[0] - ptPix[0]) + self.canvasOffset.x, \
                self.canvasScale.y * (downClickPix[1] - ptPix[1]) + \
                self.canvasOffset.y)
            self.RedrawCanvas()
        
        # Check if selecting or deselecting a region
        else:
            if iReg != -1:
                iRegInner = iReg
            else:
                iRegInner = self.InsideRegions(pt)
            
            # Do something about that region selection
            if iRegInner != -1:
                # Selecting single region
                if not event.CmdDown():
                    self.selectedRegions = []
                    self.selectedRegions.append(iRegInner)
                
                # Deselecting a region
                elif iRegInner in self.selectedRegions:
                    self.selectedRegions.remove(iRegInner)
                
                # Adding a region to the selection
                else:
                    self.selectedRegions.append(iRegInner)
            
            # Clear all region selections
            else:
                self.selectedRegions = []
            self.RedrawCanvas()
    
    def OnMouseLeftDClick(self, event):
        """Perform action based on current mode of operation."""
        
        # Set double-click flag so that next mouse-up is ignored
        self.justDoubleClicked = True
        
        # Creating a polygonal region
        if self.togglePoly.GetValue() and self.polyVerts and \
                len(self.polyVerts) > 2:
            self.CreateRegion()
        
        # Editing a region
        if self.selectedRegions and not self.toggleSquare.GetValue() and \
                not self.togglePoly.GetValue() and \
                not self.toggleDim.GetValue():
            # Unset double-click flag since event does not propagate here
            self.justDoubleClicked = False
            
            # Edit the latest selected region
            iReg = self.selectedRegions.pop()
            self.selectedRegions = []
            self.selectedRegions.append(iReg)
            self.EditRegion(self.regions[iReg])
            
    
    def OnMouseRightDown(self, event):
        """Save the right click point so it can be used later."""
        self.rightClickPt, iReg, iPt, iEd = \
            self.SnapPoint(self.Pix2Map(event.GetPosition()))

    def OnMouseRightUp(self, event):
        # Check if in region creation or dimensioning mode
        if self.toggleSquare.GetValue() or self.togglePoly.GetValue() or \
                self.toggleDim.GetValue():
            self.ResetMapToggles()
        # TODO: else: open some kind of right-click menu at right-click point

    def OnMouseWheel(self, event):
        """Zoom on the map canvas."""
        ptPix = event.GetPosition()
        rot = event.GetWheelRotation()          # Usually +/- multiple of 120
        scaler = 0.75 ** (rot / 120)            # Zoom in to 75%
        # Keep mouse on the same point after zooming
        # pt = ptPix * scale + offset
        # pt = ptPix * scaleNew + offsetNew
        self.canvasOffset = Point(float(ptPix[0]) * self.canvasScale.x * \
            (1 - scaler) + self.canvasOffset.x, float(ptPix[1]) * \
            self.canvasScale.y * (1 - scaler) + self.canvasOffset.y)
        self.canvasScale = self.canvasScale * scaler
        self.RedrawCanvas()
    
    def OnKeyDown(self, event):
        keycode = event.GetKeyCode()
        
        # Backspace/Delete - Deletes selected regions
        if (keycode == wx.WXK_BACK or keycode == wx.WXK_DELETE) and \
                self.selectedRegions and not self.togglePoly.GetValue() and \
                not self.toggleSquare.GetValue():
            self.selectedRegions.sort()
            while self.selectedRegions:
                self.DeleteRegion(self.selectedRegions.pop())
        
        # Backspace/Delete - Removes last set point during region creation
        elif (keycode == wx.WXK_BACK or keycode == wx.WXK_DELETE) and \
                self.polyVerts:
            if self.toggleSquare.GetValue() or self.togglePoly.GetValue():
                self.polyVerts.pop()
                self.polySnaps.pop()
                self.RedrawCanvas()
            elif self.toggleDim.GetValue():
                self.polyVerts = []
        
        # Escape - Stops region/dimension creation
        elif keycode == wx.WXK_ESCAPE and (self.toggleSquare.GetValue() or \
                self.togglePoly.GetValue() or self.toggleDim.GetValue()):
            self.ResetMapToggles()
        
        # Ctrl+n - New
        elif event.CmdDown() and keycode == 78:
            self.OnMenuNew(None)
        
        # Ctrl+o - Open
        elif event.CmdDown() and keycode == 79:
            self.OnMenuOpen(None)
        
        # Ctrl+s - Save
        elif event.CmdDown() and keycode == 83:
            self.OnMenuSave(None)
        
        # Ctrl+q - Quit
        elif event.CmdDown() and keycode == 81:
            self.OnMenuExit(None)
        
        # Ctrl+z - Undo
        elif event.CmdDown() and keycode == 90:
            self.OnMenuUndo(None)
        
        # Ctrl+y - Redo
        elif event.CmdDown() and keycode == 89:
            self.OnMenuRedo(None)
        
        # Ctrl+a - Select All
        elif event.CmdDown() and keycode == 65:
            self.selectedRegions = range(len(self.regions))
            self.RedrawCanvas()
        
        # Pass event on so other key combinations still work
        else:
            event.Skip()
    
    def OnEnterWindow(self, event):
        """Set the focus to the canvas to enable zooming."""
        self.canvas.SetFocus()
    
    def OnLeaveWindow(self, event):
        """Unset the focus from the canvas to disable zooming."""
        self.SetFocus()
    
    def OnCanvasPaint(self, event):
        """Redraw the contents of the canvas panel."""
        # Set up to draw
        dc = wx.PaintDC(self.canvas)
        self.RedrawCanvas(dc)
    
    def RedrawCanvas(self, dc=None):
        """Redraw the contents of the canvas panel.
        Callable from outside or inside EVT_PAINT handler.
        
        dc - Device context object for drawing to canvas.
        """
        # Clear canvas
        self.canvas.ClearBackground()
        
        # Create device context if not created
        if not dc:
            dc = wx.WindowDC(self.canvas)
        
        # Draw grid background
        self.DrawGrid(dc)
        
        # Redraw all markers
        self.DrawMarkers(self.markerPoses, dc)
        
        # Redraw all regions
        for region in self.regions:
            self.DrawRegion(region, dc)
        
        # Redraw all transition face indicators
        # Lower triangular matrix only
        for iReg in range(1, len(self.adjacent)):
            self.DrawAdjacencies(iReg, dc)
        
        # Redraw selection handles
        for iReg in self.selectedRegions:
            self.DrawSelectionHandle(iReg, dc)
        
        # Redraw partial region
        if self.toggleSquare.GetValue() or self.togglePoly.GetValue():
            for iVert in range(len(self.polyVerts) - 1):
                ptPix1 = self.Map2Pix(self.polyVerts[iVert])
                ptPix2 = self.Map2Pix(self.polyVerts[iVert + 1])
                dc.DrawLine(ptPix1[0], ptPix1[1], ptPix2[0], ptPix2[1])
    
    def DrawGrid(self, dc=None):
        """Draw the axes and grid on the map canvas.

        dc - Device context used for drawing on the canvas panel.
        """
        # Create device context if not created
        if not dc:
            dc = wx.WindowDC(self.canvas)

        # Draw axes
        xOff = self.canvasOffset.x
        yOff = self.canvasOffset.y
        xPixOff = int(-xOff / self.canvasScale.x)
        yPixOff = int(-yOff / self.canvasScale.y)
        colLim, rowLim = self.canvas.GetSize()
        dc.DrawLine(0, yPixOff, colLim, yPixOff)
        dc.DrawLine(xPixOff, 0, xPixOff, rowLim)

        # TODO: Draw grid/ticks

    def DrawMarkers(self, poses, dc=None):
        """Draw markers at specified global positions.

        poses - List of tuples containing positions of markers in meters
                [(x, y), ...]
        dc - Device context used for drawing on the canvas panel.
        """
        # Create device context if not created
        if not dc:
            dc = wx.WindowDC(self.canvas)

        # Draw each marker
        for pose in poses:
            posePix = self.Map2Pix(pose)
            dc.DrawCircle(posePix[0], posePix[1], 5)
    
    def DrawSelectionHandle(self, iReg, dc=None):
        """Draw markers indicating region(s) that have been selected by mouse.
        
        iReg - Index of region selected
        dc - Device context used for drawing on the canvas panel
        """
        # Create device context if not created
        if not dc:
            dc = wx.WindowDC(self.canvas)
        
        for pt in self.regions[iReg].verts:
            ptPix = self.Map2Pix(pt)
            dc.DrawCircle(ptPix[0], ptPix[1], 5)

    def DrawRegion(self, region, dc=None):
        """Draw a single region.

        region - Instance of Region class, contains information about the region.
        dc - Device context used for drawing on the canvas panel.
        """
        # Create device context if not created
        if not dc:
            dc = wx.WindowDC(self.canvas)

        # Draw region
        vertsPix = []
        for vert in region.verts:
            vertsPix.append(self.Map2Pix(vert))
        dc.DrawPolygon(vertsPix)
    
    def DrawAdjacencies(self, iReg, dc=None):
        """Draw lines to show adjacent region faces for one region.
        Uses self.regions and self.adjacent.
        
        iReg - Int, index of region of interest in self.regions.
        dc - Device context used for drawing on the canvas panel.
        """
        # Create device context if not created
        if not dc:
            dc = wx.WindowDC(self.canvas)
        oldPen = dc.GetPen()
        dc.SetPen(wx.Pen(wx.Colour(255, 0, 0, 100), 3, wx.SHORT_DASH))
        
        # Iterate adjacency matrix looking for shared faces for one region
        # Only need to iterate through lower triangle (not counting diagonal) 
        # since the matrix is "symmetric" and diagonal is just region to itself
        for jReg in range(iReg):
            for iREdge1, iREdge2 in self.adjacent[iReg][jReg]:
                # Not last edge in region
                pt1 = self.regions[iReg].verts[iREdge1]
                if iREdge1 < len(self.regions[iReg].verts) - 1:
                    pt2 = self.regions[iReg].verts[iREdge1 + 1]
                # Last edge in region
                else:
                    pt2 = self.regions[iReg].verts[0]
                pt1Pix = self.Map2Pix(pt1)
                pt2Pix = self.Map2Pix(pt2)
                dc.DrawLine(pt1Pix[0], pt1Pix[1], pt2Pix[0], pt2Pix[1])
        dc.SetPen(oldPen)   # TODO: Maybe can remove if everything sets own pen
    
    def ResetMapToggles(self, toggleStay=None):
        """Clear all the other map-feature toggle buttons.
        Also resets region creation.

        toggleStay - Toggle button object to retain state.
        """
        # Reset region creation and clear temporary lines
        self.polyVerts = []
        self.polySnaps = []
        self.RedrawCanvas()

        # Turn off all toggles and revert specified one
        if toggleStay:
            state = toggleStay.GetValue()
        self.toggleSquare.SetValue(False)
        self.togglePoly.SetValue(False)
        self.toggleDim.SetValue(False)
        if toggleStay:
            toggleStay.SetValue(state)

    def CreateRegion(self):
        """Instantiate and create a region, perform cleanup actions.
        Use polyVerts and polyAdjEdges to make the region and find transitions.
        """
        # Create region
        rName = 'r' + str(len(self.regions))
        region = Region(self.polyVerts, rName)
        self.regions.append(region)
        idxNewReg = len(self.regions) - 1
        # Add row and column to list of lists of lists representing adjacency
        self.adjacent.append([[] for col in xrange(len(self.adjacent))])
        for row in self.adjacent:
            row.append([])
        self.AddToUndo(Action(None, region))
        # TODO: Change Undo setup so that adjacency matrix can be added with
        #       regions in one undo step
        
        self.RecalcAdjacency(idxNewReg)
        
        # Cleanup and draw
        self.polyVerts = []
        self.polySnaps = []
        self.polyAdjEdges = []
        self.DrawRegion(region)
        self.DrawAdjacencies(idxNewReg)
    
    def DeleteRegion(self, iReg):
        """Removes region from regions list and adjacency list.
        
        iReg - Index of region to remove
        """
        # Remove region from tracking lists
        self.regions.pop(iReg)
        self.adjacent.pop(iReg)
        for jReg in range(len(self.regions)):
            self.adjacent[jReg].pop(iReg)
        
        # Redraw regions
        self.RedrawCanvas()
        
        # TODO: Add to undo

    def AddPointToRegion(self, pt, iReg, iEdge):
        """Add a vertex to the region.
        
        pt - Point object, location of new vertex in map coordinates
             Unless this is a new Point object, it is recommended that this be
             a copy of the previous Point object
             AddPointToRegion(copy.copy(pt), iReg, iEdge)
        iRegion - Int, index of region to modify
        iEdge - Int, index of the edge to replace with edges to and from pt
        """
        # Add point to other region
        self.regions[iReg].verts.insert(iEdge + 1, pt)
        # Update all transition edges
        # Loop through all regions
        for jReg in range(len(self.adjacent[iReg])):
            # All transitioning faces from region to others
            for kPair in range(len(self.adjacent[iReg][jReg])):
                thisRegFace, otherRegFace = self.adjacent[iReg][jReg][kPair]
                # Transition face has index greater than affected edge
                if thisRegFace > iEdge:
                    self.adjacent[iReg][jReg][kPair] = \
                        (thisRegFace + 1, otherRegFace)
                # Transition face is the affected edge
                elif thisRegFace == iEdge:
                    self.adjacent[iReg][jReg].\
                        append((thisRegFace + 1, otherRegFace))
            # All transitioning faces from other regions to this one
            for kPair in range(len(self.adjacent[jReg][iReg])):
                otherRegFace, thisRegFace = self.adjacent[jReg][iReg][kPair]
                # Transition face has index greater than affected edge
                if thisRegFace > iEdge:
                    self.adjacent[jReg][iReg][kPair] = \
                        (otherRegFace, thisRegFace + 1)
                # Transition face is the affected edge
                elif thisRegFace == iEdge:
                    self.adjacent[jReg][iReg].\
                        append((otherRegFace, thisRegFace + 1))
    
    def EditRegion(self, reg):
        """Show the edit region dialog.
        Allow user to change name, color, and obstacleness of a region.
        
        reg - Region to edit
        """
        # Create dialog
        regEdDia = RegionEditDialog(self, wx.ID_ANY, "Edit Region Information")
        
        # Set appropriate control values
        regEdDia.textName.SetValue(reg.name)
        regEdDia.colorPicker.SetColour(reg.color)
        regEdDia.chkbxObst.SetValue(reg.isObstacle)
        
        # Wait for user to close the dialog
        done = False
        while not done:
            answer = regEdDia.ShowModal()
            # User canceled
            if answer == wx.ID_CANCEL:
                regEdDia.Destroy()
                done = True
            # Same name or unique new name
            elif regEdDia.textName.GetValue() == reg.name or \
                    regEdDia.textName.GetValue() not in \
                    [r.name for r in self.regions]:
                reg.name = regEdDia.textName.GetValue()
                reg.color = regEdDia.colorPicker.GetColour()
                reg.isObstacle = regEdDia.chkbxObst.GetValue()
                regEdDia.Destroy()
                done = True
            # Non-unique name - needs to re-edit
            else:
                wx.MessageBox("Region with name \"%s\" already exists." % \
                    (regEdDia.textName.GetValue()), "Error", \
                    style = wx.OK | wx.ICON_ERROR)
        
        # Redraw the regions to ensure correct name/color
        self.RedrawCanvas()
        # TODO: Add to undo
    
    def RecalcAdjacency(self, iReg, iRegStart=0):
        """Recalculate the adjacent walls between the specified region and
        other regions. If walls or points are "close enough" to being colinear
        or colocated, they will be moved so that they overlap. The saved
        adjacency matrix will be updated accordingly.
        
        Can specify which region to start checking with so that the input
        region will not check against all regions. This is useful if entire map
        needs to be rechecked, it can be done so with:
        
            for iReg, reg in enumerate(self.regions):
                self.RecalcAdjacency(iReg, iRegStart=iReg)
        
        This will avoid redundant checking of regions. Note that the function
        will avoid checking against itself, so there is no reason to avoid
        calling it on itself.
        
        iReg - Index of region of interest
        iRegStart - Specifies to check reg against self.regions[iRegStart:]
        """
        # Reset adjacency related to this region
        for iOthReg in range(len(self.regions)):
            self.adjacent[iReg][iOthReg] = []
            self.adjacent[iOthReg][iReg] = []
        
        # Pull region for easy access
        reg = self.regions[iReg]
        
        # Keeps track of the colocation of vertices of this region with points
        # of other regions
        # List of lists of tuples
        # Outer list - len(vertColloc) == len(reg.verts)
        # Inner list - Contains collocation information for each region vertex
        # Tuple - Contains collocation information from vertex on this region
        #         to vertex on another region in the format:
        #         (iReg, iPt)
        vertsColloc = [[] for iPt in xrange(len(reg.verts))]
        
        # Check all other regions against this region
        for iOthReg in range(len(self.regions[iRegStart:])):
            # No need to check against self
            if iOthReg == iReg:
                continue
            
            for iOthPt, othPt in enumerate(self.regions[iOthReg].verts):
                pt, iPt, iEd, snapped = self.Snap1Region(reg, othPt)
                # Other region vertex snapped to wall of new region
                if iEd != -1:
                    # Add point to new region and update old transitions
                    self.AddPointToRegion(copy.copy(pt), iReg, iEd)
                    vertsColloc.append([])
                    # Don't bother tracking point connectivity here
                    # Recheck it in next loop so we can look at all regions
        
        # Check this region against others and create new vertices as necessary
        for iPt, pt in enumerate(reg.verts):
            snapResults = self.SnapRegions(pt, checkAll=True)
            # Process the "nearness" information
            for othPt, iOthReg, iOthPt, iOthEd in snapResults:
                # Ignore same region
                if iOthReg == iReg:
                    continue
                
                # Change region point location
                pt.Set(othPt.x, othPt.y)
                
                # Snapped to a point in the other region
                if iOthPt != -1:
                    vertsColloc[iPt].append((iOthReg, iOthPt))
                # Snapped to an edge of the other region
                elif iOthEd != -1:
                    self.AddPointToRegion(copy.copy(pt), iOthReg, iOthEd)
                    vertsColloc[iPt].append((iOthReg, iOthEd + 1))
        
        # Now look for adjacent edges and update transition matrix accordingly
        for iPt in range(len(reg.verts)):       # Start point of edge
            jPt = (iPt + 1) % len(reg.verts)    # End point of edge
            for iOthReg, iOthPt in vertsColloc[iPt]:
                jOthPt1 = (iOthPt - 1) % len(self.regions[iOthReg].verts)
                jOthPt2 = (iOthPt + 1) % len(self.regions[iOthReg].verts)
                # Check edge on other region prior to point
                if (iOthReg, jOthPt1) in vertsColloc[jPt]:
                    # Indicate transition from this region to other region
                    # from current this region side to other region side
                    # and reverse transition as well
                    self.adjacent[iReg][iOthReg].append((iPt, jOthPt1))
                    self.adjacent[iOthReg][iReg].append((jOthPt1, iPt))
                # Check edge on other region after point
                elif (iOthReg, jOthPt2) in vertsColloc[jPt]:
                    self.adjacent[iReg][iOthReg].append((iPt, iOthPt))
                    self.adjacent[iOthReg][iReg].append((iOthPt, iPt))
    
    def Autoboundary(self):
        """Automatically create region representing the boundary of the map."""
        # Check that there are regions first
        if self.regions:
            # Find extrema of map
            minx = float('inf')
            maxx = float('-inf')
            miny = float('inf')
            maxy = float('-inf')
            for reg in self.regions:
                for pt in reg.verts:
                    minx = min(minx, pt.x)
                    maxx = max(maxx, pt.x)
                    miny = min(miny, pt.y)
                    maxy = max(maxy, pt.y)
            
            # Create region
            points = [Point(minx, maxy), Point(maxx, maxy), \
                Point(maxx, miny), Point(minx, miny)]
            self.boundary = Region(points, 'boundary')

    def AddToUndo(self, action):
        """Add specified action to the undo queue.

        action - Action object to be added
        """
        # Note that this is only called when doing a new action,
        # not when redoing since this clears the redo buffer
        self.undoActions.append(action)
        while len(self.undoActions) > self.unredoBufLen:
            self.undoActions.popleft()
        self.redoActions.clear()
        # TODO: enable self.menuUndo

    def SnapPoint(self, pt):
        """Snap the point to any nearby Vicon or region point.

        pt - Point object, map coordinates of point
        returns - (snappedPt, idxRegion, idxRPoint, idxREdge)
            snappedPt - Point object, point after snapping
            idxRegion - int, index of region if snapped to region point/edge
                        if not snapped to region it will be -1
            idxRPoint - int, index of point in region.verts if snapped to point
                        if not snapped to point it will be -1
            idxREdge - int, index of side in region if snapped to edge
                       edge j is defined by region.verts[j:j+1]
                       if not snapped to edge it will be -1
        """
        # TODO: Make menubar checkbox to disable/enable snapto
        # Check through all region points and edges first
        # (since Vicon points may be moving around)
        snapped = False
        pt, idxRegion, idxRPoint, idxREdge, snapped = \
            self.SnapRegions(pt, snapped=snapped)

        # Check points in current region creation
        # Only snap to vertices
        # Don't count this for iRegion or iRPoint
        pt, idxPolyPoint, snapped = self.SnapPoly(pt, snapped=snapped)

        # Check all Vicon points
        pt, idxMarker, snapped = self.SnapVicon(pt, snapped)

        # Only return region indices, since they are usually all that matter
        return pt, idxRegion, idxRPoint, idxREdge

    def SnapRegions(self, pt, checkAll=False, snapped=False):
        """Snap the point to any sufficiently "nearby" region vertex or wall.

        pt - Point object, map coordinates of point
        checkAll - Boolean, true if this function should check the point
                   against all regions, even if it has already snapped to one
        snapped - Boolean, true if point has snapped already, false if not
                  If point is already snapped, this function will just return
        returns -
            If checkAll is true, then the return will be a list containing
            tuples in the format (snappedPt, idxRegion, idxRPoint, idxREdge),
            where each entry is as described below. If there is no snapping
            then the list will be empty.
            If checkAll is false, then a single tuple will be returned:
            (snappedPt, idxRegion, idxRPoint, idxREdge, snapped)
                snappedPt - Point object, point after snapping
                idxRegion - int, index of region if snapped to region point/edge
                            if not snapped to region it will be -1
                idxRPoint - int, index of point in region.verts if snapped to point
                            if not snapped to point it will be -1
                idxREdge - int, index of side in region if snapped to edge
                           edge j is defined by region.verts[j:j+1]
                           if not snapped to edge it will be -1
                snapped - Boolean, true if point has been snapped, false if not
                          Note that if input snapped is true, output will be true
                          even if the point did not snap to a region point or edge
        """
        # Initialize output
        if not checkAll:
            idxRegion = -1
            idxRPoint = -1
            idxREdge = -1
        else:
            output = []
        
        # Check through regions
        i = len(self.regions) - 1   # Region decrementer
        while (checkAll or not snapped) and i >= 0:
            pt, idxRPoint, idxREdge, snapped = \
                self.Snap1Region(self.regions[i], pt, \
                snapped=(not checkAll and snapped))
            if idxRPoint != -1 or idxREdge != -1:
                idxRegion = i
                if checkAll:
                    output.append((pt, idxRegion, idxRPoint, idxREdge))
            i -= 1
        
        if not checkAll:
            return pt, idxRegion, idxRPoint, idxREdge, snapped
        else:
            return output
    
    def Snap1Region(self, region, pt, snapped=False):
        """Snap the point to any sufficiently "nearby" region vertex or wall
        in the specified region.
        
        region - Region object, region of interest
        pt - Point object, map coordinates of point
        snapped - Boolean, true is point has snapped already, false if not
                  If point is already snapped, this function will just return
        returns - (snappedPt, idxRPoint, idxREdge, snapped)
            snappedPt - Point object, point after snapping
            idxRPoint - int, index of point in region.verts if snapped to point
                        if not snapped to point it will be -1
            idxREdge - int, index of side in region if snapped to edge
                       edge j is defined by region.verts[j:j+1]
                       if not snapped to edge it will be -1
            snapped - Boolean, true if point has been snapped, false if not
                      Note that if input snapped is true, output will be true
                      even if the point did not snap to a region point or edge
        """
        idxRPoint = -1
        idxREdge = -1
        # Check first point
        chkPt = region.verts[0]
        if (not snapped) and pt.Dist(chkPt) < self.tolerance:
            pt = chkPt
            snapped = True
            idxRPoint = 0
        j = 1   # Region point incrementer
        while (not snapped) and j < len(region.verts):
            # Check next point
            chkPt = region.verts[j]
            if pt.Dist(chkPt) < self.tolerance:
                pt = chkPt
                snapped = True
                idxRPoint = j
            # Check edge between previous and just-checked point
            else:
                p0 = region.verts[j - 1]
                p1 = chkPt
                chkPt = self.ProjPtOnLine(pt, p0, p1)
                # Check that projected point is on finite line and close
                if pt.Dist(chkPt) < self.tolerance and \
                        chkPt.x <= max(p0.x, p1.x) and \
                        chkPt.x >= min(p0.x, p1.x) and \
                        chkPt.y <= max(p0.y, p1.y) and \
                        chkPt.y >= min(p0.y, p1.y):
                    pt = chkPt
                    snapped = True
                    idxREdge = j - 1
            j += 1
        # Check last edge
        if not snapped:
            p0 = region.verts[j - 1]
            p1 = region.verts[0]
            chkPt = self.ProjPtOnLine(pt, p0, p1)
            if pt.Dist(chkPt) < self.tolerance and \
                    chkPt.x <= max(p0.x, p1.x) and \
                    chkPt.x >= min(p0.x, p1.x) and \
                    chkPt.y <= max(p0.y, p1.y) and \
                    chkPt.y >= min(p0.y, p1.y):
                pt = chkPt
                snapped = True
                idxREdge = j - 1
        
        return pt, idxRPoint, idxREdge, snapped
    
    def SnapPoly(self, pt, snapped=False):
        """Snap the point to any vertex in the currently being created region
        if it is sufficiently "nearby".

        pt - Point object, map coordinates of point
        snapped - Boolean, true is point has snapped already, false if not
                  If point is already snapped, this function will just return
        returns - (snappedPt, idxPoint, snapped)
            snappedPt - Point object, point after snapping
            idxPoint - int, index of point in self.polyVerts if snapped to it
                       if not snapped to point it will be -1
            snapped - Boolean, true if point has been snapped, false if not
                      Note that if input snapped is true, output will be true
                      even if the point did not snap to a polygon point
        """
        idxPoint = -1
        i = 0       # Misc point incrementer
        while (not snapped) and i < len(self.polyVerts):
            chkPt = self.polyVerts[i]
            if pt.Dist(chkPt) < self.tolerance:
                pt = chkPt
                idxPoint = i
                snapped = True
            i += 1

        return pt, idxPoint, snapped

    def SnapVicon(self, pt, snapped):
        """Snap the point to any saved Vicon marker position if it is
        sufficiently "nearby".

        pt - Point object, map coordinates of point
        snapped - Boolean, true is point has snapped already, false if not
                  If point is already snapped, this function will just return
        returns - (snappedPt, idxMarker, snapped)
            snappedPt - Point object, point after snapping
            idxMarker - int, index of point in self.markerPoses if snapped
                        if not snapped to point it will be -1
            snapped - Boolean, true if point has been snapped, false if not
                      Note that if input snapped is true, output will be true
                      even if the point did not snap to a Vicon point
        """
        idxMarker = -1
        i = 0       # Vicon point incrementer
        while (not snapped) and i < len(self.markerPoses):
            chkPt = self.markerPoses[i]
            if pt.Dist(chkPt) < self.tolerance:
                pt = chkPt
                idxMarker = i
                snapped = True
            i += 1

        return pt, idxMarker, snapped
    
    def InsideRegions(self, pt):
        """Find region containing point. Looks through regions on top first
        (those that were created later).
        
        pt - Point, point of interest
        returns - int, index of containing region, or -1 if none
        """
        iReg = -1
        i = len(self.regions) - 1
        while iReg == -1 and i >= 0:
            if self.regions[i].PtInRegion(pt):
                iReg = i
            i -= 1
        
        return iReg
    
    def Map2Pix(self, pose):
        """Convert from map coordinates to pixel coordinates.

        pose - Point, map coordinates of point
        returns - Tuple, pixel coordinates in canvas panel (col, row)
        """
        col = int((pose.x - self.canvasOffset.x) / self.canvasScale.x)
        row = int((pose.y - self.canvasOffset.y) / self.canvasScale.y)
        return (col, row)

    def Pix2Map(self, pixPose):
        """Convert from pixel coordinates to map coordinates.

        pixPose - Tuple, pixel coordinates in canvas panel (col, row)
        returns - Point, map coordinates of point
        """
        x = float(pixPose[0]) * self.canvasScale.x + self.canvasOffset.x
        y = float(pixPose[1]) * self.canvasScale.y + self.canvasOffset.y
        return Point(x, y)

    def ProjPtOnLine(self, pt, p0, p1):
        """Find the projection of a point on an infinite line.

        pt - Point object, point to be projected.
        p1 - Point object, one endpoint of line.
        p2 - Point object, other endpoint of line.
        returns - Point object, projected point on line.
        """
        s = p1 - p0                     # Vector to project on (p0 is origin)
        v = pt - p0                     # Vector to point to project
        u = (v.Dot(s) / s.Dot(s)) * s   # Projected vector
        return p0 + u                   # Map back to global coordinates
# end of class RegionEditor


class FeedbackDialog(wx.Dialog):
    def __init__(self, *args, **kwds):
        # begin wxGlade: FeedbackDialog.__init__
        kwds["style"] = wx.DEFAULT_DIALOG_STYLE
        wx.Dialog.__init__(self, *args, **kwds)
        self.buttonPrev = wx.Button(self, -1, "Previous")
        self.buttonPick = wx.Button(self, -1, "Select")
        self.buttonNext = wx.Button(self, -1, "Next")
        self.chkbxIterate = wx.CheckBox(self, -1, "Automatically iterate points when marker is in position")
        self.radioboxOption = wx.RadioBox(self, -1, "Feedback Method", choices=["Speech", "Beeping"], majorDimension=1, style=wx.RA_SPECIFY_ROWS)
        self.chkbxMute = wx.CheckBox(self, -1, "Mute")

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_BUTTON, self.OnButtonPrev, self.buttonPrev)
        self.Bind(wx.EVT_BUTTON, self.OnButtonPick, self.buttonPick)
        self.Bind(wx.EVT_BUTTON, self.OnButtonNext, self.buttonNext)
        # end wxGlade

        # Add close event handler to cleanup before closing
        self.Bind(wx.EVT_CLOSE, self.OnClose)

        # Save reference to RegionEditor GUI
        if len(args) > 0:
            self.parent = args[0]
        else:
            print "Warning: FeedbackDialog will not work without " + \
                "reference to RegionEditor GUI as first parameter."
            self.parent = None

        # Track current point
        self.chkbxIterate.SetValue(True)
        self.currReg = 0
        self.currPt = 0

        # Start audio feedback thread
        self.feedbackThread = AudioFeedbackThread(self, self.parent)
        self.feedbackThread.start()

    def __set_properties(self):
        # begin wxGlade: FeedbackDialog.__set_properties
        self.SetTitle("Marker Placement")
        self.buttonPrev.SetMinSize((50, 50))
        self.buttonPick.SetMinSize((50, 50))
        self.buttonNext.SetMinSize((50, 50))
        self.chkbxIterate.SetValue(1)
        self.radioboxOption.SetSelection(0)
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: FeedbackDialog.__do_layout
        sizerOuter = wx.BoxSizer(wx.VERTICAL)
        sizerOptions = wx.BoxSizer(wx.VERTICAL)
        sizerButtons = wx.BoxSizer(wx.HORIZONTAL)
        sizerButtons.Add(self.buttonPrev, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)
        sizerButtons.Add(self.buttonPick, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)
        sizerButtons.Add(self.buttonNext, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)
        sizerOuter.Add(sizerButtons, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        sizerOptions.Add(self.chkbxIterate, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)
        sizerOptions.Add(self.radioboxOption, 0, wx.ALL | wx.EXPAND, 5)
        sizerOptions.Add(self.chkbxMute, 0, wx.ALL, 5)
        sizerOuter.Add(sizerOptions, 1, wx.EXPAND, 0)
        self.SetSizer(sizerOuter)
        sizerOuter.Fit(self)
        self.Layout()
        # end wxGlade

    def OnClose(self, event):
        """Perform cleanup tasks and close the feedback dialog."""
        self.feedbackThread.stop()
        self.parent.toggleFeedback.SetValue(False)
        # TODO: Add wait/notify to make sure thread ended
        self.Destroy()

    def OnButtonPrev(self, event):  # wxGlade: FeedbackDialog.<event_handler>
        """Move back to previous point."""
        # Not first point in region
        if self.currPt > 0:
            self.currPt -= 1
        # First point in region
        else:
            # Not first region
            if self.currReg > 0:
                self.currReg -= 1
            # First region
            else:
                self.currReg = len(self.parent.regions) - 1
            self.currPt = len(self.parent.regions[self.currReg].verts) - 1

    def OnButtonPick(self, event):  # wxGlade: FeedbackDialog.<event_handler>
        #self.parent.Raise()
        print "Select not yet implemented."

    def OnButtonNext(self, event):  # wxGlade: FeedbackDialog.<event_handler>
        """Move on to next point."""
        # Not last point in region
        if self.currPt < len(self.parent.regions[self.currReg].verts) - 1:
            self.currPt += 1
        # Last point in region
        else:
            # Not last region
            if self.currReg < len(self.parent.regions) - 1:
                self.currReg += 1
            # Last region
            else:
                self.currReg = 0
            self.currPt = 0
# end of class FeedbackDialog

class RegionEditDialog(wx.Dialog):
    def __init__(self, *args, **kwds):
        # begin wxGlade: RegionEditDialog.__init__
        kwds["style"] = wx.DEFAULT_DIALOG_STYLE
        wx.Dialog.__init__(self, *args, **kwds)
        self.label_1 = wx.StaticText(self, -1, "Name: ")
        self.textName = wx.TextCtrl(self, -1, "")
        self.label_2 = wx.StaticText(self, -1, "Color: ")
        self.colorPicker = wx.ColourPickerCtrl(self, -1)
        self.chkbxObst = wx.CheckBox(self, -1, "Treat as obstacle")
        self.buttonOk = wx.Button(self, wx.ID_OK, "OK")
        self.buttonCancel = wx.Button(self, wx.ID_CANCEL, "Cancel")

        self.__set_properties()
        self.__do_layout()
        # end wxGlade

    def __set_properties(self):
        # begin wxGlade: RegionEditDialog.__set_properties
        self.SetTitle("Edit Region")
        self.colorPicker.SetMinSize((40, 40))
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: RegionEditDialog.__do_layout
        sizer_2 = wx.BoxSizer(wx.VERTICAL)
        sizer_5 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_4 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_3 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_3.Add(self.label_1, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)
        sizer_3.Add(self.textName, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)
        sizer_2.Add(sizer_3, 1, wx.EXPAND, 0)
        sizer_4.Add(self.label_2, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)
        sizer_4.Add(self.colorPicker, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)
        sizer_2.Add(sizer_4, 1, wx.EXPAND, 0)
        sizer_2.Add(self.chkbxObst, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_5.Add(self.buttonOk, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)
        sizer_5.Add(self.buttonCancel, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 8)
        sizer_2.Add(sizer_5, 1, wx.EXPAND, 0)
        self.SetSizer(sizer_2)
        sizer_2.Fit(self)
        self.Layout()
        # end wxGlade
# end of class RegionEditDialog

class Region:
    def __init__(self, points, name, rgb=None):
        """Create an object to represent a region.

        points - List of Points containing vertex information
                 [Point(x1, y1), Point(x2, y2), ...]
        name - String defining region name
        rgb - List of integers defining color
              [red, green, blue], each with value in range [0 255]
        """
        # TODO: Add convex/concave
        self.verts = points
        self.name = name
        if not rgb:
            rgb = [random.randint(0, 255), random.randint(0, 255), \
                random.randint(0,255)]
        self.color = wx.Colour(rgb[0], rgb[1], rgb[2])
        self.isObstacle = False
    
    def __str__(self):
        """Representation of object."""
        s = "%s\t{%03d\t%03d\t%03d}\t[" % (self.name, self.color.Red(), \
            self.color.Green(), self.color.Blue())
        for iPt, pt in enumerate(self.verts):
            s += str(pt)
            if iPt < len(self.verts) - 1:
                s += "\t"
        s += "]"
        return s
    
    def PtInRegion(self, pt):
        """Check if a point is inside of the region.
        Algorithm taken from C# version of Solution 1 from
        http://local.wasp.uwa.edu.au/~pbourke/geometry/insidepoly/
        
        pt - Point to check
        returns - Boolean, True if the point is inside of the region
        """
        result = False
        n = len(self.verts)
        for i in range(n):
            j = (i + 1) % n
            if ((self.verts[j].y <= pt.y and pt.y < self.verts[i].y) or \
                    (self.verts[i].y <= pt.y and pt.y < self.verts[j].y)) and \
                    pt.x < (self.verts[i].x - self.verts[j].x) * \
                    (pt.y - self.verts[j].y) / \
                    (self.verts[i].y - self.verts[j].y) + self.verts[j].x:
                result = not result
        return result
# end of class Region


class Action:
    def __init__(self, oldState, newState):
        """Create an object that represents an (un/re)doable action.

        oldState - Previous state of the affected object(s)
        newState - Changed state of the affected object(s)

        These arguments will usually be one or more regions that were changed.
        An argument of "None" indicates either creation or deletion.
        """
        self.oldState = oldState
        self.newState = newState
# end of class Action


class Point:
    def __init__(self, x, y):
        """Create an object that allows floating point vector operations.

        x - Float, first coordinate of point
        y - Float, second coordinate of point
        """
        if isinstance(x, float) and isinstance(y, float):
            self.x = x
            self.y = y
        else:
            raise TypeError('\'Point\' creation takes only \'float\' values')

    def __str__(self):
        """Representation of object."""
        return '(%.3f\t%.3f)' % (self.x, self.y)

    def __hash__(self):
        """Hashtable representation of object."""
        tup = (self.x, self.y)
        return tup.__hash__()

    def __eq__(self, other):
        """Checks equality (self == other)."""
        return isinstance(other, Point) and self.x == other.x and self.y == other.y

    def __ne__(self, other):
        """Checks non-equality (self != other)."""
        return not self.__eq__(other)

    def __add__(self, other):
        """Addition operator (self + other)."""
        if isinstance(other, Point):
            return Point(self.x + other.x, self.y + other.y)
        elif isinstance(other, tuple) and len(other) == 2:
            return Point(self.x + other[0], self.y + other[1])
        else:
            raise TypeError('cannot add \'Point\' and \'' + \
                other.__class__.__name__ + '\' objects')

    def __radd__(self, other):
        """Right addition operator (other + self)."""
        return self.__add__(other)

    def __sub__(self, other):
        """Subtraction operator (self - other)."""
        if isinstance(other, Point):
            return Point(self.x - other.x, self.y - other.y)
        elif isinstance(other, tuple) and len(other) == 2:
            return Point(self.x - other[0], self.y - other[1])
        else:
            raise TypeError('cannot subtract \'Point\' and \'' + \
                other.__class__.__name__ + '\' objects')

    def __rsub__(self, other):
        """Right subtraction operator (other - self)."""
        if isinstance(other, Point):
            return Point(other.x - self.x, other.y - self.y)
        elif isinstance(other, tuple) and len(other) == 2:
            return Point(other[0] - self.x, other[1] - self.y)
        else:
            raise TypeError('cannot subtract \'Point\' and \'' + \
                other.__class__.__name__ + '\' objects')

    def __mul__(self, other):
        """Multiplication operator (self * other)."""
        if isinstance(other, float):
            return Point(self.x * other, self.y * other)
        else:
            raise TypeError('cannot multiply \'Point\' and \'' + \
                other.__class__.__name__ + '\' objects')

    def __rmul__(self, other):
        """Right multiplication operator (other * self)."""
        return self.__mul__(other)

    def __div__(self, other):
        """Division operator (self / other)."""
        if isinstance(other, float):
            return Point(self.x / other, self.y / other)
        else:
            raise TypeError('cannot divide \'Point\' and \'' + \
                other.__class__.__name__ + '\' objects')

    def __truediv__(self, other):
        """True division operator."""
        return self.__div__(other)
    
    def Set(self, x, y):
        """Change the value of the point."""
        self.x = x
        self.y = y

    def Dot(self, other):
        """Dot product."""
        if isinstance(other, Point):
            return self.x * other.x + self.y * other.y
        elif isinstance(other, tuple) and len(other) == 2:
            return self.x * other[0] + self.y * other[1]
        else:
            raise TypeError('cannot compute dot product of \'Point\' and \'' + \
                other.__class__.__name__ + '\' object')

    def Dist(self, other):
        """Euclidean distance from this point to the other."""
        if isinstance(other, Point):
            return math.sqrt((self.x - other.x) ** 2 + \
                (self.y - other.y) ** 2)
        elif isinstance(other, tuple) and len(other) == 2:
            return math.sqrt((self.x - other[0]) ** 2 + \
                (self.y - other[1]) ** 2)
        else:
            raise TypeError('cannot compute distance from \'Point\' to \'' + \
                other.__class__.__name__ + '\' object')

    def Norm(self):
        """Length of the vector."""
        return math.sqrt(self.x ** 2 + self.y ** 2)
# end of class Point


class ViconMarkerListener(threading.Thread):
    def __init__(self, parent):
        """Create the a socket to receive Vicon data."""
        super(ViconMarkerListener, self).__init__()

        # Communication parameters
        self.parent = parent        # RegionEditor GUI
        self.addr = ("0.0.0.0", 7500)
        self.bufsize = 65536
        self.udpSock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.lock = threading.Lock()
        self.close = threading.Event()
        self.updateFreq = 20    # Hz

        # Tracking parameters
        # TODO: Set all paremeters in configuration of GUI
        self.minDist = 0.01     # Distance to move to qualify as movement
        self.maxDist = 0.1      # Qualified as new point
        self.movMaxTime = 15 * self.updateFreq  # (sec)*(Hz)
                                # Iterations during which marker is not moving
                                # before stopping tracking
        self.invMaxTime = 1 * self.updateFreq   # (sec)*(Hz)
                                # Iterations during which marker is not found
                                # before stopping tracking

        # Tracking containers
        self.oldPoses = []      # Previous marker positions
        self.movingPoses = []   # Markers that are moving
        self.movingTimeout = [] # Iterations left before movement timeout
        self.invisTimeout = []  # Iteractions left before not-found timeout

    def run(self):
        """Open the socket to start communication. Process messages."""
        # Open socket for communication
        self.udpSock.bind(self.addr)

        # Receive communication until stopped
        self.close.clear()
        delay = 1 / self.updateFreq
        while not self.close.isSet():
            self.lock.acquire()
            data = self.udpSock.recv(self.bufsize)
            self.lock.release()
            self.ProcessData(data)
            time.sleep(delay)

        # Close socket
        self.udpSock.close()
        self.oldPoses = []
        self.movingPoses = []
        self.movingTimeout = []
        self.invisTimeout = []

    def stop(self):
        """Close the socket to end UDP communication."""
        self.close.set()

    # Deserialize and save data
    def ProcessData(self, data):
        """Extract marker positions and pass them on to be mapped.

        data - Byte array encoded from multiple pairs of doubles [x1 y1 ...]
        """
        # Check for valid data (not null or incomplete)
        if data and len(data)%16 == 0:
            poses = []
            for i in range(0, len(data), 16):
                x, y = struct.unpack('dd', data[i:i+16])
                poses.append(Point(x, y))
            # Save and plot marker positions
            self.parent.markerPoses = poses
            self.UpdateMovingMarkers(poses)
            self.parent.RedrawCanvas()      # Force map redraw

    def UpdateMovingMarkers(self, poses):
        """Note which markers are newly moving and update position of old
        moving markers based on change in position from previous list.

        poses - List of Points, marker positions.
        """
        # Not first time through
        if self.oldPoses:
            # Check all currently tracked markers first
            for iMarker, markerPose in enumerate(self.movingPoses):
                closestIdx = self.FindClosest(poses, markerPose)
                closestDist = markerPose.Dist(poses[closestIdx])
                # Same marker
                if closestDist < self.maxDist:
                    self.invisTimeout[iMarker] = self.invMaxTime
                    # Is moving
                    if closestDist > self.minDist:
                        self.movingTimeout[iMarker] = self.movMaxTime + 1
                    self.movingPoses[iMarker] = poses[closestIdx]
                # Marker not seen
                else:
                    self.invisTimeout[iMarker] -= 1
                self.movingTimeout[iMarker] -= 1
                # Marker has stopped moving or not been seen for some time
                if self.invisTimeout[iMarker] == 0 or \
                        self.movingTimeout[iMarker] == 0:
                    self.invisTimeout.pop(iMarker)
                    self.movingTimeout.pop(iMarker)
                    self.movingPoses.pop(iMarker)
            # Check through all new markers next
            for markerPose in poses:
                closestIdx = self.FindClosest(self.oldPoses, markerPose)
                closestDist = markerPose.Dist(self.oldPoses[closestIdx])
                # Point is moving
                if closestDist < self.maxDist and closestDist > self.minDist:
                    self.movingPoses.append(markerPose)
                    self.movingTimeout.append(self.movMaxTime)
                    self.invisTimeout.append(self.invMaxTime)
        self.oldPoses = poses

    def FindClosest(self, points, target):
        """Find the closest point to the target.

        points - List of Points, marker positions.
        target - Point, point to find marker closest to.
        returns - Integer, index of closest point in points.
        """
        # Iterate through all points
        minDist = float('inf')
        minIdx = 0
        for i, pt in enumerate(points):
            dist = target.Dist(pt)
            if dist < minDist:
                minIdx = i
                minDist = dist
        return minIdx
# end of class ViconMarkerListener


class AudioFeedbackThread(threading.Thread):
    def __init__(self, feedbackDialog, regEditor):
        """Create audio feedback for marker placement.

        fbDia - Dialog box that specifies the point of interest.
        regEd - RegionEditor GUI that gets Vicon information.
        """
        super(AudioFeedbackThread, self).__init__()

        # Save other objects
        self.fbDia = feedbackDialog
        self.regEd = regEditor
        
        # Non-audio parameters
        self.close = threading.Event()
        self.tolerance = 0.10   # Close-enough distance (m)
        self.maxDist = 2.5      # Points must be within this to react (m)

        # Audio parameters for beeping
        # Chosen for audibility at distance
        # TODO: Make modifiable by configuration file
        minFreq = 600           # Lowest frequency played (Hz)
        maxFreq = 7000          # Highest frequency played (Hz)
        updateFreq = 2.0        # Frequency of possible sound change (Hz)
        self.duration = int(1000.0 / updateFreq)
        
        # Audio parameters for text-to-speech
        self.engine = pyttsx.init()
        self.engine.setProperty('rate', 120)
        self.engine.setProperty('volume', 1.0)
        self.speechFormat = "X %.1f, Y %.1f"
        self.speechPause = 1.0  # Pause between voice commands

        # Calculate the line representing the distance-frequency mapping
        self.freqSlope = (minFreq - maxFreq) / (self.maxDist - self.tolerance)
        self.freqIntercept = maxFreq - self.tolerance * self.freqSlope

    def run(self):
        """Play sound based on distance of moving marker to goal point."""
        self.close.clear()
        while not self.close.isSet():
            soundOption = self.fbDia.radioboxOption.GetSelection()
            if not self.fbDia.chkbxMute.GetValue():
                # Get distance from closest marker to point of interest
                intPt = self.regEd.regions[self.fbDia.currReg].\
                    verts[self.fbDia.currPt]
                minStatDistToPt = 2.0 * self.maxDist
                for statPt in self.regEd.markerPoses:
                    if not statPt in self.regEd.viconListener.movingPoses:
                        minStatDistToPt = min(minStatDistToPt, intPt.Dist(statPt))

                # Get distance from closest moving point to point of interest
                minDistToPt = 2.0 * self.maxDist
                minPtIdx = -1
                for iPt, movPt in \
                        enumerate(self.regEd.viconListener.movingPoses):
                    dist = intPt.Dist(movPt)
                    if dist < minDistToPt:
                        minDistToPt = dist
                        minPtIdx = iPt

                # Plot moving point and goal point
                dc = wx.WindowDC(self.regEd.canvas)
                dc.SetBrush(wx.Brush(wx.Colour(255, 0, 0, 100), wx.SOLID))
                posePix = self.regEd.Map2Pix(intPt)
                dc.DrawCircle(posePix[0], posePix[1], 8)
                if minPtIdx > -1 and minPtIdx < \
                        len(self.regEd.viconListener.movingPoses):
                    posePix = self.regEd.Map2Pix(\
                        self.regEd.viconListener.movingPoses[minPtIdx])
                    dc.DrawCircle(posePix[0], posePix[1], 8)

                # Close-enough
                if minDistToPt < self.tolerance or \
                        minStatDistToPt < self.tolerance:
                    # Marker is settled
                    if minStatDistToPt < self.tolerance or self.regEd.\
                            viconListener.movingTimeout[minPtIdx] < \
                            self.regEd.viconListener.movMaxTime:
                        # Play "success" sound to indicate done with point
                        if soundOption:
                            time.sleep(0.2)
                            winsound.Beep(600, 200)
                            winsound.Beep(1200, 200)
                            winsound.Beep(1800, 200)
                            time.sleep(0.2)
                        else:
                            self.engine.say("Success, next")
                            self.engine.runAndWait()
                            time.sleep(self.speechPause)
                        # Switch to next point of interest if checked
                        if self.fbDia.chkbxIterate.GetValue():
                            self.fbDia.OnButtonNext(None)
                            # TODO: Check if all points are in correct spots
                            #       and stop if done

                    # Marker not yet settled
                    else:
                        # Play "good" sound to signal "stop moving marker"
                        if soundOption:
                            time.sleep(0.2)
                            winsound.Beep(1200, 200)
                            winsound.Beep(1200, 200)
                            time.sleep(0.2)
                        else:
                            self.engine.say("Stop there")
                            self.engine.runAndWait()
                            time.sleep(self.speechPause)
                
                # Still within distance of effect
                elif minDistToPt < self.maxDist:
                    if soundOption:
                        freq = int(self.freqIntercept + self.freqSlope * \
                            minDistToPt)
                        winsound.Beep(freq, self.duration)
                    else:
                        diffPt = intPt - self.regEd.viconListener.\
                            movingPoses[minPtIdx]
                        self.engine.say(self.speechFormat % \
                            (diffPt.x, diffPt.y))
                        self.engine.runAndWait()
                        time.sleep(self.speechPause)

    def stop(self):
        """Signal for the thread to end."""
        self.engine.stop()
        self.close.set()


if __name__ == "__main__":
    app = wx.PySimpleApp(0)
    wx.InitAllImageHandlers()
    if len(sys.argv) > 1:
        regEd = regionEditor(None, -1, sys.argv[1])
    else:
        regEd = regionEditor(None, -1)
    app.SetTopWindow(regEd)
    app.MainLoop()
