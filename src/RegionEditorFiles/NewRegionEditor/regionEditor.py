#!/usr/bin/env python
# -*- coding: iso-8859-15 -*-
# generated by wxGlade 0.6.5 (standalone edition) on Mon Feb 13 13:09:57 2012

import os
import sys
import collections
import time
import math
import wx
import threading
import socket
import struct
import copy
import random
import winsound
import pyttsx

# begin wxGlade: extracode
# end wxGlade

class regionEditor(wx.Frame):
    def __init__(self, *args, **kwds):
        # begin wxGlade: regionEditor.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        
        # Menu Bar
        self.RegionEditor_menubar = wx.MenuBar()
        self.filemenu = wx.Menu()
        self.menuNew = wx.MenuItem(self.filemenu, wx.NewId(), "New", "", wx.ITEM_NORMAL)
        self.filemenu.AppendItem(self.menuNew)
        self.menuOpen = wx.MenuItem(self.filemenu, wx.NewId(), "Open", "", wx.ITEM_NORMAL)
        self.filemenu.AppendItem(self.menuOpen)
        self.menuSave = wx.MenuItem(self.filemenu, wx.NewId(), "Save", "", wx.ITEM_NORMAL)
        self.filemenu.AppendItem(self.menuSave)
        self.menuSaveAs = wx.MenuItem(self.filemenu, wx.NewId(), "Save As", "", wx.ITEM_NORMAL)
        self.filemenu.AppendItem(self.menuSaveAs)
        self.menuExit = wx.MenuItem(self.filemenu, wx.NewId(), "Exit", "", wx.ITEM_NORMAL)
        self.filemenu.AppendItem(self.menuExit)
        self.RegionEditor_menubar.Append(self.filemenu, "File")
        self.menuEdit = wx.Menu()
        self.menuUndo = wx.MenuItem(self.menuEdit, wx.NewId(), "Undo", "", wx.ITEM_NORMAL)
        self.menuEdit.AppendItem(self.menuUndo)
        self.menuRedo = wx.MenuItem(self.menuEdit, wx.NewId(), "Redo", "", wx.ITEM_NORMAL)
        self.menuEdit.AppendItem(self.menuRedo)
        self.RegionEditor_menubar.Append(self.menuEdit, "Edit")
        self.menuDrawing = wx.Menu()
        self.menuAutobound = wx.MenuItem(self.menuDrawing, wx.NewId(), "Autoboundary", "", wx.ITEM_NORMAL)
        self.menuDrawing.AppendItem(self.menuAutobound)
        self.menuRect = wx.MenuItem(self.menuDrawing, wx.NewId(), "Rectangle", "", wx.ITEM_NORMAL)
        self.menuDrawing.AppendItem(self.menuRect)
        self.menuPoly = wx.MenuItem(self.menuDrawing, wx.NewId(), "Polygon", "", wx.ITEM_NORMAL)
        self.menuDrawing.AppendItem(self.menuPoly)
        self.menuAddPoint = wx.MenuItem(self.menuDrawing, wx.NewId(), "Add Point", "", wx.ITEM_NORMAL)
        self.menuDrawing.AppendItem(self.menuAddPoint)
        self.menuRemPoint = wx.MenuItem(self.menuDrawing, wx.NewId(), "Remove Point", "", wx.ITEM_NORMAL)
        self.menuDrawing.AppendItem(self.menuRemPoint)
        self.RegionEditor_menubar.Append(self.menuDrawing, "Drawing")
        self.menuView = wx.Menu()
        self.menuMarkers = wx.MenuItem(self.menuView, wx.NewId(), "Markers", "", wx.ITEM_CHECK)
        self.menuView.AppendItem(self.menuMarkers)
        self.menuMarkersClear = wx.MenuItem(self.menuView, wx.NewId(), "Clear Markers", "", wx.ITEM_NORMAL)
        self.menuView.AppendItem(self.menuMarkersClear)
        self.menuCamera = wx.MenuItem(self.menuView, wx.NewId(), "Camera Capture", "", wx.ITEM_NORMAL)
        self.menuView.AppendItem(self.menuCamera)
        self.menuImageImport = wx.MenuItem(self.menuView, wx.NewId(), "Import Background Image", "", wx.ITEM_NORMAL)
        self.menuView.AppendItem(self.menuImageImport)
        self.menuImageClear = wx.MenuItem(self.menuView, wx.NewId(), "Clear Background Image", "", wx.ITEM_NORMAL)
        self.menuView.AppendItem(self.menuImageClear)
        self.RegionEditor_menubar.Append(self.menuView, "View")
        self.helpmenu = wx.Menu()
        self.menuAbout = wx.MenuItem(self.helpmenu, wx.NewId(), "About", "", wx.ITEM_NORMAL)
        self.helpmenu.AppendItem(self.menuAbout)
        self.RegionEditor_menubar.Append(self.helpmenu, "Help")
        self.SetMenuBar(self.RegionEditor_menubar)
        # Menu Bar end
        self.sidebar = wx.Panel(self, -1)
        self.toggleVicon = wx.ToggleButton(self.sidebar, -1, "Vicon")
        self.buttonCamera = wx.Button(self.sidebar, -1, "Camera")
        self.toggleSquare = wx.ToggleButton(self.sidebar, -1, "Rect.")
        self.togglePoly = wx.ToggleButton(self.sidebar, -1, "Polygon")
        self.toggleDim = wx.ToggleButton(self.sidebar, -1, "Length")
        self.toggleFeedback = wx.ToggleButton(self.sidebar, -1, "Feedback")
        self.buttonCal = wx.Button(self.sidebar, -1, "Calibrate")
        self.canvas = wx.Panel(self, -1, style=wx.SUNKEN_BORDER | wx.TAB_TRAVERSAL)

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_MENU, self.OnMenuNew, self.menuNew)
        self.Bind(wx.EVT_MENU, self.OnMenuOpen, self.menuOpen)
        self.Bind(wx.EVT_MENU, self.OnMenuSave, self.menuSave)
        self.Bind(wx.EVT_MENU, self.OnMenuSaveAs, self.menuSaveAs)
        self.Bind(wx.EVT_MENU, self.OnMenuExit, self.menuExit)
        self.Bind(wx.EVT_MENU, self.OnMenuUndo, self.menuUndo)
        self.Bind(wx.EVT_MENU, self.OnMenuRedo, self.menuRedo)
        self.Bind(wx.EVT_MENU, self.OnMenuAutobound, self.menuAutobound)
        self.Bind(wx.EVT_MENU, self.OnMenuRect, self.menuRect)
        self.Bind(wx.EVT_MENU, self.OnMenuPoly, self.menuPoly)
        self.Bind(wx.EVT_MENU, self.OnMenuAddPoint, self.menuAddPoint)
        self.Bind(wx.EVT_MENU, self.OnMenuRemPoint, self.menuRemPoint)
        self.Bind(wx.EVT_MENU, self.OnMenuMarkers, self.menuMarkers)
        self.Bind(wx.EVT_MENU, self.OnMenuMarkersClear, self.menuMarkersClear)
        self.Bind(wx.EVT_MENU, self.OnMenuCamera, self.menuCamera)
        self.Bind(wx.EVT_MENU, self.OnMenuImageImport, self.menuImageImport)
        self.Bind(wx.EVT_MENU, self.OnMenuImageClear, self.menuImageClear)
        self.Bind(wx.EVT_MENU, self.OnMenuAbout, self.menuAbout)
        self.Bind(wx.EVT_TOGGLEBUTTON, self.OnToggleVicon, self.toggleVicon)
        self.Bind(wx.EVT_BUTTON, self.OnButtonCamera, self.buttonCamera)
        self.Bind(wx.EVT_TOGGLEBUTTON, self.OnToggleSquare, self.toggleSquare)
        self.Bind(wx.EVT_TOGGLEBUTTON, self.OnTogglePoly, self.togglePoly)
        self.Bind(wx.EVT_TOGGLEBUTTON, self.OnToggleDim, self.toggleDim)
        self.Bind(wx.EVT_TOGGLEBUTTON, self.OnToggleFeedback, self.toggleFeedback)
        self.Bind(wx.EVT_BUTTON, self.OnButtonCal, self.buttonCal)
        # end wxGlade
        
        # Handle input
        if len(args) > 2 and isinstance(args[2], str):
            self.fileName = os.path.join(os.getcwd(), args[2])
        else:
            self.fileName = ""
        
        # Bind mouse events
        self.canvas.Bind(wx.EVT_LEFT_DOWN, self.OnMouseLeftDown, self.canvas)
        self.canvas.Bind(wx.EVT_LEFT_UP, self.OnMouseLeftUp, self.canvas)
        #self.canvas.Bind(wx.EVT_LEFT_DCLICK, self.OnMouseLeftDClick, self.canvas)
        self.canvas.Bind(wx.EVT_RIGHT_DOWN, self.OnMouseRightDown, self.canvas)
        self.canvas.Bind(wx.EVT_RIGHT_UP, self.OnMouseRightUp, self.canvas)
        self.canvas.Bind(wx.EVT_MOUSEWHEEL, self.OnMouseWheel, self.canvas)
        self.canvas.Bind(wx.EVT_ENTER_WINDOW, self.OnEnterWindow, self.canvas)
        self.canvas.Bind(wx.EVT_LEAVE_WINDOW, self.OnLeaveWindow, self.canvas)
        
        # Bind keyboard events
        self.Bind(wx.EVT_KEY_DOWN, self.OnKeyDown, self)
        self.canvas.Bind(wx.EVT_KEY_DOWN, self.OnKeyDown, self.canvas)
        
        # Determine mapping of the canvas panel to the field
        canvasLen = self.canvas.GetSize()       # Initial size of canvas (pixels)
        fieldRange = [(-3.0, 9.0), (-3.0, 3.0)] # Initial range of field (m)
                                                # [(xmin, xmax), (ymin, ymax)]
        # pose = pixPose * scale + offset
        # Note: y-pixels and y-pose have opposite directions
        xScale = (fieldRange[0][1] - fieldRange[0][0]) / float(canvasLen[0])
        xOffset = fieldRange[0][0]
        yScale = -(fieldRange[1][1] - fieldRange[1][0]) / float(canvasLen[1])
        yOffset = -fieldRange[1][0]
        self.canvasScale = Point(xScale, yScale)
        self.canvasOffset = Point(xOffset, yOffset)
        
        # Set up for region creation
        self.regions = []                   # List of regions in the map
        self.adjacent = []                  # List of lists holding transition
                                            # edges between regions.
                                            # adjacent[i][j] contains a list of
                                            # indices of edges in region i that
                                            # connect to edges in region j.
                                            # adjacent[j][i] should contain a
                                            # list of the same length, but edge
                                            # indices are for region j.
                                            # adjacent[i][i] will be empty.
        self.leftClickPt = Point(0.0, 0.0)  # Location of last left downclick
        self.rightClickPt = Point(0.0, 0.0) # Location of last right downclick
        self.tolerance = 5.0 * xScale       # Distance to consider as "same point" (m)
        self.polyVerts = []                 # Keeps points for region creation
                                            # and dimensioning
                                            # Region creation: [Point(x0,y0), ...]
                                            # Dimensioning: (idxRegion, idxVert)
        self.polySnaps = []                 # Keeps snap information for each
                                            # new region creation point
                                            # [(idxReg, idxPt, idxEdge), ...]
        
        # Set up for undo/redo capabilities
        # TODO: Disable self.menuUndo and self.menuRedo
        self.unredoBufLen = 50
        self.undoActions = collections.deque()
        self.redoActions = collections.deque()
        
        # Add paint event handler to draw on the canvas
        self.Bind(wx.EVT_PAINT, self.OnCanvasPaint, self.canvas)
        
        # Create Vicon listener
        self.markerPoses = []   # Marker positions to be drawn
        self.viconListener = ViconMarkerListener(self)
        self.dlgFeedback = None
        
        # Add close event handler to cleanup and possibly save before closing
        self.Bind(wx.EVT_CLOSE, self.OnClose)
        
        # Display the GUI window and set up the map canvas
        self.Show()
        self.DrawGrid()
    
    def __set_properties(self):
        # begin wxGlade: regionEditor.__set_properties
        self.SetTitle("Region Editor")
        self.toggleVicon.SetMinSize((50, 50))
        self.buttonCamera.SetMinSize((50, 50))
        self.toggleSquare.SetMinSize((50, 50))
        self.togglePoly.SetMinSize((50, 50))
        self.toggleDim.SetMinSize((50, 50))
        self.toggleFeedback.SetMinSize((50, 50))
        self.buttonCal.SetMinSize((50, 50))
        self.sidebar.SetMinSize((150, 400))
        self.canvas.SetMinSize((800, 400))
        self.canvas.SetBackgroundColour(wx.Colour(255, 255, 255))
        # end wxGlade
    
    def __do_layout(self):
        # begin wxGlade: regionEditor.__do_layout
        sizer_1 = wx.BoxSizer(wx.HORIZONTAL)
        grid_sizer_1 = wx.GridSizer(4, 2, 5, 5)
        grid_sizer_1.Add(self.toggleVicon, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        grid_sizer_1.Add(self.buttonCamera, 1, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        grid_sizer_1.Add(self.toggleSquare, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        grid_sizer_1.Add(self.togglePoly, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        grid_sizer_1.Add(self.toggleDim, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        grid_sizer_1.Add(self.toggleFeedback, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        grid_sizer_1.Add(self.buttonCal, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        self.sidebar.SetSizer(grid_sizer_1)
        sizer_1.Add(self.sidebar, 0, wx.EXPAND, 0)
        sizer_1.Add(self.canvas, 1, wx.EXPAND, 0)
        self.SetSizer(sizer_1)
        sizer_1.Fit(self)
        self.Layout()
        # end wxGlade
    
    def OnClose(self, event):
        """Perform cleanup tasks and close the application."""
        # Check if the closure can even be canceled
        # TODO: Check if map is unsaved and ask if they want to save before closing
        if not event or event.CanVeto():
            dlg = wx.MessageDialog(self,
                "Do you really want to close this application?",
                "Confirm Exit", wx.OK|wx.CANCEL|wx.ICON_QUESTION)
            result = dlg.ShowModal()
            dlg.Destroy()
            if result == wx.ID_OK:
                self.viconListener.stop()
                # TODO: Check if vicon is indeed running, and put wait-notify
                #       in to close port before closing GUI
                self.Destroy()
        else:
            self.viconListener.stop()
            self.Destroy()

    def OnToggleVicon(self, event):  # wxGlade: regionEditor.<event_handler>
        # Switch Vicon streaming on or off based on state of toggle button
        if self.toggleVicon.GetValue():
            self.viconListener.start()
            
            # TODO: Add while loop to wait for data to come in
            #       If it times out print message
            #       If data comes in, zoom out to ensure all markers seen
        else:
            self.viconListener.stop()
            # Reinitialize thread to enable restarting it
            self.viconListener = ViconMarkerListener(self)

    def OnButtonCamera(self, event):  # wxGlade: regionEditor.<event_handler>
        print "Camera not yet implemented"
        # TODO
        event.Skip()

    def OnToggleSquare(self, event):  # wxGlade: regionEditor.<event_handler>
        self.ResetMapToggles(self.toggleSquare)

    def OnTogglePoly(self, event):  # wxGlade: regionEditor.<event_handler>
        self.ResetMapToggles(self.togglePoly)

    def OnToggleDim(self, event):  # wxGlade: regionEditor.<event_handler>
        self.ResetMapToggles(self.toggleDim)

    def OnToggleFeedback(self, event):  # wxGlade: regionEditor.<event_handler>
        self.ResetMapToggles(self.toggleFeedback)
        if self.toggleFeedback.GetValue():
            self.dlgFeedback = FeedbackDialog(self)
            self.dlgFeedback.ShowModal()
        elif self.dlgFeedback:
            self.dlgFeedback.OnClose(None)

    def OnButtonCal(self, event):  # wxGlade: regionEditor.<event_handler>
        # TODO
        print "Calibration not yet implemented"
        self.ResetMapToggles()
    
    def OnMenuNew(self, event):  # wxGlade: regionEditor.<event_handler>
        print "Event handler `OnMenuNew' not implemented"
        event.Skip()
    
    def OnMenuOpen(self, event):  # wxGlade: regionEditor.<event_handler>
        print "Event handler `OnMenuOpen' not implemented"
        event.Skip()
    
    def OnMenuSave(self, event):  # wxGlade: regionEditor.<event_handler>
        """Save to file that has already been used."""
        if self.fileName:
            f = open(self.fileName, 'w')
            f.write("# This is a region definition file for the LTLMoP " + \
                "toolkit.\n# Format details are described at the " + \
                "beginning of each section below.\n# Note that all values " + \
                "are separated by *tabs*.\n\nBackground: # Relative path " + \
                "of background image file\n")
            f.write("None\n\n")     # TODO: Support for background images
            f.write("Obstacles: # Indices of regions to treat as obstacles\n")
            f.write("\n\n")         # TODO: Support for obstacles
            f.write("Regions: # Name {ColorR ColorG ColorB} " + \
                "[(x1 y1) (x2 y2) ...]\n")
            for reg in self.regions:
                f.write(str(reg) + "\n")
            f.write("\n")
            f.write("Thumbnail: # Relative path of image file that has " + \
                "region shapes overlayed on background image\n")
            f.write("None\n\n")         # TODO: Save png thumbnail
            f.write("Transitions: # Region1Idx Region2Idx " + \
                "[(Reg1FaceIdx1 Reg2FaceIdx1) (Reg1FaceIdx2 Reg2FaceIdx2) " + \
                "...]\n")
            for iAdj in range(len(self.adjacent)):
                for jAdj, adjList in enumerate(self.adjacent[iAdj]):
                    if iAdj != jAdj and adjList:
                        line = "%d\t%d\t[" % (iAdj, jAdj)
                        for kAdj, adj in enumerate(adjList):
                            line += "(%d\t%d)" % adj
                            if kAdj < len(adjList) - 1:
                                line += "\t"
                        line += "]\n"
                        f.write(line)
            f.close()
        else:
            self.OnMenuSaveAs(None)
    
    def OnMenuSaveAs(self, event):  # wxGlade: regionEditor.<event_handler>
        dialogSave = wx.FileDialog(self, message="Save File As", \
            defaultDir=sys.path[0], \
            defaultFile=self.fileName.split('\\').pop(), \
            wildcard="*.regions", style=wx.FD_SAVE|wx.FD_OVERWRITE_PROMPT)
        # Hit Save and confirmed overwrite if necessary
        if dialogSave.ShowModal() == wx.ID_OK:
            self.fileName = dialogSave.GetPath()
            self.OnMenuSave(None)
        dialogSave.Destroy()

    def OnMenuExit(self, event):  # wxGlade: regionEditor.<event_handler>
        self.OnClose(None)

    def OnMenuUndo(self, event):  # wxGlade: regionEditor.<event_handler>
        """Revert the most recent undoable change."""
        # Currently drawing polygon
        # Note that this is not a redoable action by design
        if self.polyVerts:
            self.polyVerts = []
            self.polySnaps = []
            self.RedrawCanvas()
        # Other undoable changes exist
        elif self.undoActions:
            action = self.undoActions.pop()
            # Creation action
            if not action.oldState:
                # Single region creation
                if isinstance(action.newState, Region):
                    self.regions.remove(action.newState)
                # Map load from blank canvas
                if isinstance(action.newState, list):
                    self.regions = []
                # TODO: Background image load from blank
            # Deletion action
            if not action.newState:
                # Single region deletion
                if isinstance(action.oldState, Region):
                    self.regions.append(action.oldState)
                # Multiple region deletion or map clear
                if isinstance(action.oldState, list):
                    self.regions.extend(action.oldState)
                # TODO: Background image clear
            # Modification action
            else:
                # Single region modification
                if isinstance(action.oldState, Region):
                    idx = self.regions.index(action.newState)
                    self.regions[idx] = action.oldState
                # Map load from non-blank canvas
                if isinstance(action.oldState, list):
                    self.regions = action.oldState
                # TODO: Background image load from other image
            self.redoActions.append(action)
            # TODO: if not self.undoActions: disable self.menuUndo
            # TODO: enable self.menuRedo
            self.RedrawCanvas()

    def OnMenuRedo(self, event):  # wxGlade: regionEditor.<event_handler>
        """Reapply most recently undone action."""
        # Redoable actions exist
        if self.redoActions:
            action = self.redoActions.pop()
            # Creation action
            if not action.oldState:
                # Single region creation
                if isinstance(action.newState, Region):
                    self.regions.append(action.newState)
                # Map load from blank canvas
                if isinstance(action.newState, list):
                    self.regions = action.newState
                # TODO: Background image load from blank
            # Deletion action
            if not action.newState:
                # Single region deletion
                if isinstance(action.oldState, Region):
                    self.regions.remove(action.oldState)
                # Multiple region deletion or map clear
                if isinstance(action.oldState, list):
                    for reg in action.oldState:
                        self.regions.remove(reg)
                # TODO: Background image clear
            # Modification action
            else:
                # Single region modification
                if isinstance(action.oldState, Region):
                    idx = self.regions.index(action.oldState)
                    self.regions[idx] = action.newState
                # Map load from non-blank canvas
                if isinstance(action.oldState, list):
                    self.regions = action.newState
                # TODO: Background image load from other image
            self.undoActions.append(action)
            # TODO: if not self.redoActions: disable self.menuRedo
            # TODO: enable self.menuUndo
            self.RedrawCanvas()

    def OnMenuAutobound(self, event):  # wxGlade: regionEditor.<event_handler>
        print "Event handler `OnMenuAutobound' not implemented"
        event.Skip()

    def OnMenuRect(self, event):  # wxGlade: regionEditor.<event_handler>
        print "Event handler `OnMenuRect' not implemented"
        event.Skip()

    def OnMenuPoly(self, event):  # wxGlade: regionEditor.<event_handler>
        print "Event handler `OnMenuPoly' not implemented"
        event.Skip()

    def OnMenuAddPoint(self, event):  # wxGlade: regionEditor.<event_handler>
        print "Event handler `OnMenuAddPoint' not implemented"
        event.Skip()

    def OnMenuRemPoint(self, event):  # wxGlade: regionEditor.<event_handler>
        print "Event handler `OnMenuRemPoint' not implemented"
        event.Skip()

    def OnMenuMarkers(self, event):  # wxGlade: regionEditor.<event_handler>
        print "Event handler `OnMenuMarkers' not implemented"
        event.Skip()

    def OnMenuMarkersClear(self, event):  # wxGlade: regionEditor.<event_handler>
        print "Event handler `OnMenuMarkersClear' not implemented"
        event.Skip()

    def OnMenuCamera(self, event):  # wxGlade: regionEditor.<event_handler>
        print "Event handler `OnMenuCamera' not implemented"
        event.Skip()

    def OnMenuImageImport(self, event):  # wxGlade: regionEditor.<event_handler>
        print "Event handler `OnMenuImageImport' not implemented"
        event.Skip()

    def OnMenuImageClear(self, event):  # wxGlade: regionEditor.<event_handler>
        print "Event handler `OnMenuImageClear' not implemented"
        event.Skip()
    
    def OnMenuAbout(self, event):  # wxGlade: regionEditor.<event_handler>
        print "About not yet implemented"
        event.Skip()

    def OnMouseLeftDown(self, event):
        """Save the left click point so it can be used later."""
        self.leftClickPt, iReg, iPt, iEd = \
            self.SnapPoint(self.Pix2Map(event.GetPosition()))

    def OnMouseLeftUp(self, event):
        """Perform appropriate action based on current mode of operation."""
        # Get click position
        ptPix = event.GetPosition()
        pt, iReg, iPt, iEd = self.SnapPoint(self.Pix2Map(ptPix))

        # Creating a rectangular region
        if self.toggleSquare.GetValue():
            # Making the second corner of rectangle
            if self.polyVerts:
                # Snap vertices to regions as necessary, not to Vicon
                # This may result in a non-square region, but may be preferable
                x0 = self.polyVerts[0].x
                y0 = self.polyVerts[0].y
                pt1, iReg1, iPt1, iEd1, snapped1 = \
                    self.SnapRegions(Point(x0, pt.y), False)
                pt3, iReg3, iPt3, iEd3, snapped3 = \
                    self.SnapRegions(Point(pt.x, y0), False)
                # Move clicked points if other vertices snap and they don't
                if snapped1:
                    if iReg == -1:
                        pt = Point(pt.x, pt1.y)
                    if self.polySnaps[0][0] == -1:
                        self.polyVerts[0] = Point(pt1.x, self.polyVerts[0].y)
                if snapped3:
                    if iReg == -1:
                        pt = Point(pt3.x, pt.y)
                    if self.polySnaps[0][0] == -1:
                        self.polyVerts[0] = Point(self.polyVerts[0].x, pt3.y)
                self.polyVerts.append(pt1)
                self.polyVerts.append(pt)
                self.polyVerts.append(pt3)
                self.polySnaps.append((iReg1, iPt1, iEd1))
                self.polySnaps.append((iReg, iPt, iEd))
                self.polySnaps.append((iReg3, iPt3, iEd3))
                # Create a square between previous click and new click
                self.CreateRegion()
            # Making the first corner of rectangle
            else:
                # Save point as first corner of square
                self.polyVerts.append(pt)
                self.polySnaps.append((iReg, iPt, iEd))

        # Creating a polygonal region
        elif self.togglePoly.GetValue():
            # Closing the polygon to create a region
            if self.polyVerts and len(self.polyVerts) > 2 and \
                    pt == self.polyVerts[0]:
                self.CreateRegion()
            # New point distinct from others
            elif not pt in self.polyVerts:
                self.polyVerts.append(pt)
                self.polySnaps.append((iReg, iPt, iEd))
                # Plot line between last two points
                if len(self.polyVerts) > 1:
                    x1pix, y1pix = self.Map2Pix(self.polyVerts[-2])
                    x2pix, y2pix = self.Map2Pix(pt)
                    dc = wx.WindowDC(self.canvas)
                    dc.DrawLine(x1pix, y1pix, x2pix, y2pix)

        # Dimensioning region edge
        elif self.toggleDim.GetValue():
            # First point on region to be clicked
            if not self.polyVerts and iReg != -1 and iPt != -1:
                # Store region and point indeces
                self.polyVerts = (iReg, iPt)
            # Second unique point to be clicked
            elif iReg != -1 and iPt != -1 and (iReg, iPt) != self.polyVerts:
                # Request dimension
                currDist = self.regions[iReg].verts[iPt].Dist(self.regions[\
                    self.polyVerts[0]].verts[self.polyVerts[1]])
                dimDlg = wx.TextEntryDialog(self, \
                    "Current Length: %.3f" % currDist, caption='Dimension')
                if dimDlg.ShowModal() == wx.ID_OK:
                    # Check for valid dimension (allow negative values)
                    try:
                        dim = float(dimDlg.GetValue())
                    except ValueError:
                        dimDlg.Destroy()
                        return
                    dimDlg.Destroy()

                    # Move second point along same line to specified distance
                    oldRegion = copy.deepcopy(self.regions[iReg])
                    pt0 = self.regions[self.polyVerts[0]].verts[self.polyVerts[1]]
                    signx = 1.0
                    signy = 1.0
                    # Vertical line case
                    if pt0.x == pt.x:
                        if pt0.y > pt.y:
                            signy = -1.0
                        dx = 0.0
                        dy = signy * (dim - pt.Dist(pt0))
                    # Horizontal and normal line cases
                    else:
                        if pt0.x > pt.x:
                            signx = -1.0
                        if pt0.y > pt.y:
                            signy = -1.0
                        slope = (pt.y - pt0.y) / (pt.x - pt0.x)
                        dx = signx * (dim - pt.Dist(pt0)) / \
                            math.sqrt(1 + slope ** 2)
                        dy = slope * dx
                    self.regions[iReg].verts[iPt] = \
                        self.regions[iReg].verts[iPt] + Point(dx, dy)
                    self.AddToUndo(Action(oldRegion, self.regions[iReg]))
                    self.polyVerts = []
                    self.RedrawCanvas()

        # Panning the map view
        elif pt.Dist(self.leftClickPt) > self.tolerance:
            downClickPix = self.Map2Pix(self.leftClickPt)
            self.canvasOffset = Point(self.canvasScale.x * \
                (downClickPix[0] - ptPix[0]) + self.canvasOffset.x, \
                self.canvasScale.y * (downClickPix[1] - ptPix[1]) + \
                self.canvasOffset.y)
            self.RedrawCanvas()
    
    # TODO: May need to handle all mouse events in one huge window
    #       to avoid having the double click interfere with regular clicking
    #def OnMouseLeftDClick(self, event):
    #    """Perform action based on current mode of operation."""
    #    # Creating a polygonal region
    #    if self.togglePoly.GetValue() and self.polyVerts and \
    #            len(self.polyVerts) > 2:
    #        self.CreateRegion()
    
    def OnMouseRightDown(self, event):
        """Save the right click point so it can be used later."""
        self.rightClickPt, iReg, iPt, iEd = \
            self.SnapPoint(self.Pix2Map(event.GetPosition()))

    def OnMouseRightUp(self, event):
        # Check if in region creation or dimensioning mode
        if self.toggleSquare.GetValue() or self.togglePoly.GetValue() or \
                self.toggleDim.GetValue():
            self.ResetMapToggles()
        # TODO: else: open some kind of right-click menu at right-click point

    def OnMouseWheel(self, event):
        """Zoom on the map canvas."""
        ptPix = event.GetPosition()
        rot = event.GetWheelRotation()          # Usually +/- multiple of 120
        scaler = 0.75 ** (rot / 120)            # Zoom in to 75%
        # Keep mouse on the same point after zooming
        # pt = ptPix * scale + offset
        # pt = ptPix * scaleNew + offsetNew
        self.canvasOffset = Point(float(ptPix[0]) * self.canvasScale.x * \
            (1 - scaler) + self.canvasOffset.x, float(ptPix[1]) * \
            self.canvasScale.y * (1 - scaler) + self.canvasOffset.y)
        self.canvasScale = self.canvasScale * scaler
        self.RedrawCanvas()

    def OnKeyDown(self, event):
        keycode = event.GetKeyCode()
        
        # Backspace/Delete - Removes last set point during region creation
        if (keycode == wx.WXK_BACK or keycode == wx.WXK_DELETE) and \
                self.polyVerts:
            if self.toggleSquare.GetValue() or self.togglePoly.GetValue():
                self.polyVerts.pop()
                self.polySnaps.pop()
                self.RedrawCanvas()
            elif self.toggleDim.GetValue():
                self.polyVerts = []
        
        # Escape - Stops region/dimension creation
        elif keycode == wx.WXK_ESCAPE and (self.toggleSquare.GetValue() or \
                self.togglePoly.GetValue() or self.toggleDim.GetValue()):
            self.ResetMapToggles()
        
        # Ctrl+n - New
        if event.CmdDown() and keycode == 78:
            self.OnMenuNew(None)
        
        # Ctrl+o - Open
        if event.CmdDown() and keycode == 79:
            self.OnMenuOpen(None)
        
        # Ctrl+s - Save
        if event.CmdDown() and keycode == 83:
            self.OnMenuSave(None)
        
        # Ctrl+q - Quit
        if event.CmdDown() and keycode == 81:
            self.OnMenuExit(None)
        
        # Ctrl+z - Undo
        elif event.CmdDown() and keycode == 90:
            self.OnMenuUndo(None)
        
        # Ctrl+y - Redo
        elif event.CmdDown() and keycode == 89:
            self.OnMenuRedo(None)

        # Pass event on so other key combinations still work
        else:
            event.Skip()

    def OnEnterWindow(self, event):
        """Set the focus to the canvas to enable zooming."""
        self.canvas.SetFocus()

    def OnLeaveWindow(self, event):
        """Unset the focus from the canvas to disable zooming."""
        self.SetFocus()

    def OnCanvasPaint(self, event):
        """Redraw the contents of the canvas panel."""
        # Set up to draw
        dc = wx.PaintDC(self.canvas)
        self.RedrawCanvas(dc)

    def RedrawCanvas(self, dc=None):
        """Redraw the contents of the canvas panel.
        Callable from outside or inside EVT_PAINT handler.

        dc - Device context object for drawing to canvas.
        """
        # Clear canvas
        self.canvas.ClearBackground()

        # Create device context if calling from outside EVT_PAINT handler
        if not dc:
            dc = wx.WindowDC(self.canvas)

        # Redraw all markers
        self.DrawGrid(dc)
        self.DrawMarkers(self.markerPoses, dc)

        # Redraw all regions
        for region in self.regions:
            self.DrawRegion(region, dc)
        
        # Redraw all transition face indicators
        # Lower triangular matrix only
        for iReg in range(1, len(self.adjacent)):
            self.DrawAdjacencies(iReg, dc)

        # Redraw partial region
        if self.toggleSquare.GetValue() or self.togglePoly.GetValue():
            for iVert in range(len(self.polyVerts) - 1):
                ptPix1 = self.Map2Pix(self.polyVerts[iVert])
                ptPix2 = self.Map2Pix(self.polyVerts[iVert + 1])
                dc.DrawLine(ptPix1[0], ptPix1[1], ptPix2[0], ptPix2[1])

    def DrawGrid(self, dc=None):
        """Draw the axes and grid on the map canvas.

        dc - Device context used for drawing on the canvas panel.
        """
        # Create device context if calling from outside EVT_PAINT handler
        if not dc:
            dc = wx.WindowDC(self.canvas)

        # Draw axes
        xOff = self.canvasOffset.x
        yOff = self.canvasOffset.y
        xPixOff = int(-xOff / self.canvasScale.x)
        yPixOff = int(-yOff / self.canvasScale.y)
        colLim, rowLim = self.canvas.GetSize()
        dc.DrawLine(0, yPixOff, colLim, yPixOff)
        dc.DrawLine(xPixOff, 0, xPixOff, rowLim)

        # TODO: Draw grid/ticks

    def DrawMarkers(self, poses, dc=None):
        """Draw markers at specified global positions.

        poses - List of tuples containing positions of markers in meters [(x, y), ...]
        dc - Device context used for drawing on the canvas panel.
        """
        # Create device context if calling from outside EVT_PAINT handler
        if not dc:
            dc = wx.WindowDC(self.canvas)

        # Draw each marker
        for pose in poses:
            posePix = self.Map2Pix(pose)
            dc.DrawCircle(posePix[0], posePix[1], 5)

    def DrawRegion(self, region, dc=None):
        """Draw a single region.

        region - Instance of Region class, contains information about the region.
        dc - Device context used for drawing on the canvas panel.
        """
        # Create device context if calling from outside EVT_PAINT handler
        if not dc:
            dc = wx.WindowDC(self.canvas)

        # Draw region
        vertsPix = []
        for vert in region.verts:
            vertsPix.append(self.Map2Pix(vert))
        dc.DrawPolygon(vertsPix)
    
    def DrawAdjacencies(self, iReg, dc=None):
        """Draw lines to show adjacent region faces for one region.
        Uses self.regions and self.adjacent.
        
        iReg - Int, index of region of interest in self.regions.
        dc - Device context used for drawing on the canvas panel.
        """
        # Create device context if calling from outside other drawing methods
        if not dc:
            dc = wx.WindowDC(self.canvas)
        oldPen = dc.GetPen()
        dc.SetPen(wx.Pen(wx.Colour(255, 0, 0, 100), 3, wx.SHORT_DASH))
        
        # Iterate adjacency matrix looking for shared faces for one region
        # Only need to iterate through lower triangle (not counting diagonal) 
        # since the matrix is "symmetric" and diagonal is just region to itself
        for jReg in range(iReg):
            for iREdge1, iREdge2 in self.adjacent[iReg][jReg]:
                # Not last edge in region
                pt1 = self.regions[iReg].verts[iREdge1]
                if iREdge1 < len(self.regions[iReg].verts) - 1:
                    pt2 = self.regions[iReg].verts[iREdge1 + 1]
                # Last edge in region
                else:
                    pt2 = self.regions[iReg].verts[0]
                pt1Pix = self.Map2Pix(pt1)
                pt2Pix = self.Map2Pix(pt2)
                dc.DrawLine(pt1Pix[0], pt1Pix[1], pt2Pix[0], pt2Pix[1])
        dc.SetPen(oldPen)   # TODO: Maybe can remove if everything sets own pen
    
    def ResetMapToggles(self, toggleStay=None):
        """Clear all the other map-feature toggle buttons.
        Also resets region creation.

        toggleStay - Toggle button object to retain state.
        """
        # Reset region creation and clear temporary lines
        self.polyVerts = []
        self.polySnaps = []
        self.RedrawCanvas()

        # Turn off all toggles and revert specified one
        if toggleStay:
            state = toggleStay.GetValue()
        self.toggleSquare.SetValue(False)
        self.togglePoly.SetValue(False)
        self.toggleDim.SetValue(False)
        if toggleStay:
            toggleStay.SetValue(state)

    def CreateRegion(self):
        """Instantiate and create a region, perform cleanup actions.
        Use polyVerts and polyAdjEdges to make the region and find transitions.
        """
        # Create region
        rName = 'r' + str(len(self.regions))
        region = Region(self.polyVerts, rName)  # TODO: Add color to regions
        self.regions.append(region)
        idxNewReg = len(self.regions) - 1
        # Add row and column to list of lists of lists representing adjacency
        self.adjacent.append([[] for col in xrange(len(self.adjacent))])
        for row in self.adjacent:
            row.append([])
        self.AddToUndo(Action(None, region))
        # TODO: Change Undo setup so that adjacency matrix can be added with
        #       regions in one undo step

        # Look for adjacent edges to other regions
        # First add vertices in walls where another region vertex is
        # Check new region against other regions
        for iPt, (iReg, iRPoint, iREdge) in enumerate(self.polySnaps):
            # Point snapped to the edge of another region
            if iREdge != -1:
                # Add point to other region and update old transitions
                self.AddPointToRegion(self.polyVerts[iPt], iReg, iREdge)
                # Track which point it is connected to
                self.polySnaps[iPt] = (iReg, iREdge + 1, -1)
        # Check other regions against new region
        for iReg, otherReg in enumerate(self.regions):
            for iPt, pt in enumerate(otherReg.verts):
                pt, iRPoint, iREdge, snapped = \
                    self.Snap1Region(region, pt, False)
                # Other region vertex snapped to wall of new region
                if iREdge != -1:
                    # Add point to new region and update old transitions
                    self.AddPointToRegion(pt, idxNewReg, iREdge)
                    # Track which point it is connected to
                    self.polySnaps.insert(iREdge + 1, (iReg, iPt, -1))
        
        # Next look for adjacent edges and update transition matrix accordingly
        for iSide in range(len(self.polySnaps)):
            iReg1, iRPoint1, iREdge1 = self.polySnaps[iSide]
            if iSide < len(self.polySnaps) - 1:
                iReg2, iRPoint2, iREdge2 = self.polySnaps[iSide + 1]
            else:
                iReg2, iRPoint2, iREdge2 = self.polySnaps[0]
            # Same region and adjacent points
            if iReg1 != -1 and iReg1 == iReg2:
                # TODO: Could be same point that is already shared by two or
                #       more regions. Need to check for this.
                # Not last side in other region
                if abs(iRPoint1 - iRPoint2) == 1:
                    iOtherRegSide = min(iRPoint1, iRPoint2)
                    self.adjacent[idxNewReg][iReg1].\
                        append((iSide, iOtherRegSide))
                    self.adjacent[iReg1][idxNewReg].\
                        append((iOtherRegSide, iSide))
                # Last side in other region
                elif (iRPoint1 == 0 and iRPoint2 == \
                        len(self.regions[iReg2].verts) - 1) or \
                        (iRPoint2 == 0 and iRPoint1 == \
                        len(self.regions[iReg1].verts) - 1):
                    iOtherRegSide = len(self.regions[iReg1].verts) - 1
                    self.adjacent[idxNewReg][iReg1].\
                        append((iSide, iOtherRegSide))
                    self.adjacent[iReg1][idxNewReg].\
                        append((iOtherRegSide, iSide))
        
        # Cleanup and draw
        self.polyVerts = []
        self.polySnaps = []
        self.polyAdjEdges = []
        self.DrawRegion(region)
        self.DrawAdjacencies(idxNewReg)

    def AddPointToRegion(self, pt, iReg, iEdge):
        """Add a vertex to the region.
        
        pt - Point object, location of new vertex in map coordinates
        iRegion - Int, index of region to modify
        iEdge - Int, index of the edge to replace with edges to and from pt
        """
        # Add point to other region
        self.regions[iReg].verts.insert(iEdge + 1, pt)
        # Update all transition edges
        # Loop through all regions
        for jReg in range(len(self.adjacent[iReg])):
            # All transitioning faces from region to others
            for kPair in range(len(self.adjacent[iReg][jReg])):
                thisRegFace, otherRegFace = self.adjacent[iReg][jReg][kPair]
                # Transition face has index greater than affected edge
                if thisRegFace > iEdge:
                    self.adjacent[iReg][jReg][kPair] = \
                        (thisRegFace + 1, otherRegFace)
                # Transition face is the affected edge
                elif thisRegFace == iEdge:
                    self.adjacent[iReg][jReg].\
                        append((thisRegFace + 1, otherRegFace))
            # All transitioning faces from other regions to this one
            for kPair in range(len(self.adjacent[jReg][iReg])):
                otherRegFace, thisRegFace = self.adjacent[jReg][iReg][kPair]
                # Transition face has index greater than affected edge
                if thisRegFace > iEdge:
                    self.adjacent[jReg][iReg][kPair] = \
                        (otherRegFace, thisRegFace + 1)
                # Transition face is the affected edge
                elif thisRegFace == iEdge:
                    self.adjacent[jReg][iReg].\
                        append((otherRegFace, thisRegFace + 1))

    def AddToUndo(self, action):
        """Add specified action to the undo queue.

        action - Action object to be added
        """
        # Note that this is only called when doing a new action,
        # not when redoing since this clears the redo buffer
        self.undoActions.append(action)
        while len(self.undoActions) > self.unredoBufLen:
            self.undoActions.popleft()
        self.redoActions.clear()
        # TODO: enable self.menuUndo

    def SnapPoint(self, pt):
        """Snap the point to any nearby Vicon or region point.

        pt - Point object, map coordinates of point
        returns - (snappedPt, idxRegion, idxRPoint, idxREdge)
            snappedPt - Point object, point after snapping
            idxRegion - int, index of region if snapped to region point/edge
                        if not snapped to region it will be -1
            idxRPoint - int, index of point in region.verts if snapped to point
                        if not snapped to point it will be -1
            idxREdge - int, index of side in region if snapped to edge
                       edge j is defined by region.verts[j:j+1]
                       if not snapped to edge it will be -1
        """
        # TODO: Make menubar checkbox to disable/enable snapto
        # Check through all region points and edges first
        # (since Vicon points may be moving around)
        snapped = False
        pt, idxRegion, idxRPoint, idxREdge, snapped = \
            self.SnapRegions(pt, snapped)

        # Check points in current region creation
        # Only snap to vertices
        # Don't count this for iRegion or iRPoint
        pt, idxPolyPoint, snapped = self.SnapPoly(pt, snapped)

        # Check all Vicon points
        pt, idxMarker, snapped = self.SnapVicon(pt, snapped)

        # Only return region indices, since they are usually all that matter
        return pt, idxRegion, idxRPoint, idxREdge

    def SnapRegions(self, pt, snapped):
        """Snap the point to any sufficiently "nearby" region vertex or wall.

        pt - Point object, map coordinates of point
        snapped - Boolean, true is point has snapped already, false if not
                  If point is already snapped, this function will just return
        returns - (snappedPt, idxRegion, idxRPoint, idxREdge, snapped)
            snappedPt - Point object, point after snapping
            idxRegion - int, index of region if snapped to region point/edge
                        if not snapped to region it will be -1
            idxRPoint - int, index of point in region.verts if snapped to point
                        if not snapped to point it will be -1
            idxREdge - int, index of side in region if snapped to edge
                       edge j is defined by region.verts[j:j+1]
                       if not snapped to edge it will be -1
            snapped - Boolean, true if point has been snapped, false if not
                      Note that if input snapped is true, output will be true
                      even if the point did not snap to a region point or edge
        """
        idxRegion = -1
        idxRPoint = -1
        idxREdge = -1
        i = 0       # Region incrementer
        while (not snapped) and i < len(self.regions):
            pt, idxRPoint, idxREdge, snapped = \
                self.Snap1Region(self.regions[i], pt, snapped)
            if snapped:
                idxRegion = i
            i += 1

        return pt, idxRegion, idxRPoint, idxREdge, snapped
    
    def Snap1Region(self, region, pt, snapped):
        """Snap the point to any sufficiently "nearby" region vertex or wall
        in the specified region.
        
        region - Region object, region of interest
        pt - Point object, map coordinates of point
        snapped - Boolean, true is point has snapped already, false if not
                  If point is already snapped, this function will just return
        returns - (snappedPt, idxRPoint, idxREdge, snapped)
            snappedPt - Point object, point after snapping
            idxRPoint - int, index of point in region.verts if snapped to point
                        if not snapped to point it will be -1
            idxREdge - int, index of side in region if snapped to edge
                       edge j is defined by region.verts[j:j+1]
                       if not snapped to edge it will be -1
            snapped - Boolean, true if point has been snapped, false if not
                      Note that if input snapped is true, output will be true
                      even if the point did not snap to a region point or edge
        """
        idxRPoint = -1
        idxREdge = -1
        # Check first point
        chkPt = region.verts[0]
        if (not snapped) and pt.Dist(chkPt) < self.tolerance:
            pt = chkPt
            snapped = True
            idxRPoint = 0
        j = 1   # Region point incrementer
        while (not snapped) and j < len(region.verts):
            # Check next point
            chkPt = region.verts[j]
            if pt.Dist(chkPt) < self.tolerance:
                pt = chkPt
                snapped = True
                idxRPoint = j
            # Check edge between previous and just-checked point
            else:
                p0 = region.verts[j - 1]
                p1 = chkPt
                chkPt = self.ProjPtOnLine(pt, p0, p1)
                # Check that projected point is on finite line and close
                if pt.Dist(chkPt) < self.tolerance and \
                        chkPt.x <= max(p0.x, p1.x) and \
                        chkPt.x >= min(p0.x, p1.x) and \
                        chkPt.y <= max(p0.y, p1.y) and \
                        chkPt.y >= min(p0.y, p1.y):
                    pt = chkPt
                    snapped = True
                    idxREdge = j - 1
            j += 1
        # Check last edge
        if not snapped:
            p0 = region.verts[j - 1]
            p1 = region.verts[0]
            chkPt = self.ProjPtOnLine(pt, p0, p1)
            if pt.Dist(chkPt) < self.tolerance and \
                    chkPt.x <= max(p0.x, p1.x) and \
                    chkPt.x >= min(p0.x, p1.x) and \
                    chkPt.y <= max(p0.y, p1.y) and \
                    chkPt.y >= min(p0.y, p1.y):
                pt = chkPt
                snapped = True
                idxREdge = j - 1
        
        return pt, idxRPoint, idxREdge, snapped
    
    def SnapPoly(self, pt, snapped):
        """Snap the point to any vertex in the currently being created region
        if it is sufficiently "nearby".

        pt - Point object, map coordinates of point
        snapped - Boolean, true is point has snapped already, false if not
                  If point is already snapped, this function will just return
        returns - (snappedPt, idxPoint, snapped)
            snappedPt - Point object, point after snapping
            idxPoint - int, index of point in self.polyVerts if snapped to it
                       if not snapped to point it will be -1
            snapped - Boolean, true if point has been snapped, false if not
                      Note that if input snapped is true, output will be true
                      even if the point did not snap to a polygon point
        """
        idxPoint = -1
        i = 0       # Misc point incrementer
        while (not snapped) and i < len(self.polyVerts):
            chkPt = self.polyVerts[i]
            if pt.Dist(chkPt) < self.tolerance:
                pt = chkPt
                idxPoint = i
                snapped = True
            i += 1

        return pt, idxPoint, snapped

    def SnapVicon(self, pt, snapped):
        """Snap the point to any saved Vicon marker position if it is
        sufficiently "nearby".

        pt - Point object, map coordinates of point
        snapped - Boolean, true is point has snapped already, false if not
                  If point is already snapped, this function will just return
        returns - (snappedPt, idxMarker, snapped)
            snappedPt - Point object, point after snapping
            idxMarker - int, index of point in self.markerPoses if snapped
                        if not snapped to point it will be -1
            snapped - Boolean, true if point has been snapped, false if not
                      Note that if input snapped is true, output will be true
                      even if the point did not snap to a Vicon point
        """
        idxMarker = -1
        i = 0       # Vicon point incrementer
        while (not snapped) and i < len(self.markerPoses):
            chkPt = self.markerPoses[i]
            if pt.Dist(chkPt) < self.tolerance:
                pt = chkPt
                idxMarker = i
                snapped = True
            i += 1

        return pt, idxMarker, snapped

    def Map2Pix(self, pose):
        """Convert from map coordinates to pixel coordinates.

        pose - Point, map coordinates of point
        returns - Tuple, pixel coordinates in canvas panel (col, row)
        """
        col = int((pose.x - self.canvasOffset.x) / self.canvasScale.x)
        row = int((pose.y - self.canvasOffset.y) / self.canvasScale.y)
        return (col, row)

    def Pix2Map(self, pixPose):
        """Convert from pixel coordinates to map coordinates.

        pixPose - Tuple, pixel coordinates in canvas panel (col, row)
        returns - Point, map coordinates of point
        """
        x = float(pixPose[0]) * self.canvasScale.x + self.canvasOffset.x
        y = float(pixPose[1]) * self.canvasScale.y + self.canvasOffset.y
        return Point(x, y)

    def ProjPtOnLine(self, pt, p0, p1):
        """Find the projection of a point on an infinite line.

        pt - Point object, point to be projected.
        p1 - Point object, one endpoint of line.
        p2 - Point object, other endpoint of line.
        returns - Point object, projected point on line.
        """
        s = p1 - p0                     # Vector to project on (p0 is origin)
        v = pt - p0                     # Vector to point to project
        u = (v.Dot(s) / s.Dot(s)) * s   # Projected vector
        return p0 + u                   # Map back to global coordinates
# end of class RegionEditor


class FeedbackDialog(wx.Dialog):
    def __init__(self, *args, **kwds):
        # begin wxGlade: FeedbackDialog.__init__
        kwds["style"] = wx.DEFAULT_DIALOG_STYLE
        wx.Dialog.__init__(self, *args, **kwds)
        self.buttonPrev = wx.Button(self, -1, "Previous")
        self.buttonPick = wx.Button(self, -1, "Select")
        self.buttonNext = wx.Button(self, -1, "Next")
        self.chkbxIterate = wx.CheckBox(self, -1, "Automatically iterate points when marker is in position")
        self.radioboxOption = wx.RadioBox(self, -1, "Feedback Method", choices=["Speech", "Beeping"], majorDimension=1, style=wx.RA_SPECIFY_ROWS)
        self.chkbxMute = wx.CheckBox(self, -1, "Mute")

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_BUTTON, self.OnButtonPrev, self.buttonPrev)
        self.Bind(wx.EVT_BUTTON, self.OnButtonPick, self.buttonPick)
        self.Bind(wx.EVT_BUTTON, self.OnButtonNext, self.buttonNext)
        # end wxGlade

        # Add close event handler to cleanup before closing
        self.Bind(wx.EVT_CLOSE, self.OnClose)

        # Save reference to RegionEditor GUI
        if len(args) > 0:
            self.parent = args[0]
        else:
            print "Warning: FeedbackDialog will not work without " + \
                "reference to RegionEditor GUI as first parameter."
            self.parent = None

        # Track current point
        self.chkbxIterate.SetValue(True)
        self.currReg = 0
        self.currPt = 0

        # Start audio feedback thread
        self.feedbackThread = AudioFeedbackThread(self, self.parent)
        self.feedbackThread.start()

    def __set_properties(self):
        # begin wxGlade: FeedbackDialog.__set_properties
        self.SetTitle("Marker Placement")
        self.buttonPrev.SetMinSize((50, 50))
        self.buttonPick.SetMinSize((50, 50))
        self.buttonNext.SetMinSize((50, 50))
        self.chkbxIterate.SetValue(1)
        self.radioboxOption.SetSelection(0)
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: FeedbackDialog.__do_layout
        sizerOuter = wx.BoxSizer(wx.VERTICAL)
        sizerOptions = wx.BoxSizer(wx.VERTICAL)
        sizerButtons = wx.BoxSizer(wx.HORIZONTAL)
        sizerButtons.Add(self.buttonPrev, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)
        sizerButtons.Add(self.buttonPick, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)
        sizerButtons.Add(self.buttonNext, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)
        sizerOuter.Add(sizerButtons, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        sizerOptions.Add(self.chkbxIterate, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)
        sizerOptions.Add(self.radioboxOption, 0, wx.ALL | wx.EXPAND, 5)
        sizerOptions.Add(self.chkbxMute, 0, wx.ALL, 5)
        sizerOuter.Add(sizerOptions, 1, wx.EXPAND, 0)
        self.SetSizer(sizerOuter)
        sizerOuter.Fit(self)
        self.Layout()
        # end wxGlade

    def OnClose(self, event):
        """Perform cleanup tasks and close the feedback dialog."""
        self.feedbackThread.stop()
        self.parent.toggleFeedback.SetValue(False)
        # TODO: Add wait/notify to make sure thread ended
        self.Destroy()

    def OnButtonPrev(self, event):  # wxGlade: FeedbackDialog.<event_handler>
        """Move back to previous point."""
        # Not first point in region
        if self.currPt > 0:
            self.currPt -= 1
        # First point in region
        else:
            # Not first region
            if self.currReg > 0:
                self.currReg -= 1
            # First region
            else:
                self.currReg = len(self.parent.regions) - 1
            self.currPt = len(self.parent.regions[self.currReg].verts) - 1

    def OnButtonPick(self, event):  # wxGlade: FeedbackDialog.<event_handler>
        #self.parent.Raise()
        print "Select not yet implemented."

    def OnButtonNext(self, event):  # wxGlade: FeedbackDialog.<event_handler>
        """Move on to next point."""
        # Not last point in region
        if self.currPt < len(self.parent.regions[self.currReg].verts) - 1:
            self.currPt += 1
        # Last point in region
        else:
            # Not last region
            if self.currReg < len(self.parent.regions) - 1:
                self.currReg += 1
            # Last region
            else:
                self.currReg = 0
            self.currPt = 0
# end of class FeedbackDialog


class Region:
    def __init__(self, points, name, rgb=None):   # TODO: random color/name
        """Create an object to represent a region.

        points - List of tuples of floats containing vertex information
                 [(x1, y1), (x2, y2), ...]
        name - String defining region name
        rgb - List of integers defining color
              [red, green, blue], each with value in range [0 255]
        """
        # TODO: Add name, color, convex/concave, possibly adjoining edges
        self.verts = points
        self.name = name
        if not rgb:
            rgb = [random.randint(0, 255), random.randint(0, 255), \
                random.randint(0,255)]
        self.color = rgb
    
    def __str__(self):
        """Representation of object."""
        s = "%s\t{%03d\t%03d\t%03d}\t[" % \
            (self.name, self.color[0], self.color[1], self.color[2])
        for iPt, pt in enumerate(self.verts):
            s += str(pt)
            if iPt < len(self.verts) - 1:
                s += "\t"
        s += "]"
        return s
# end of class Region


class Action:
    def __init__(self, oldState, newState):
        """Create an object that represents an (un/re)doable action.

        oldState - Previous state of the affected object(s)
        newState - Changed state of the affected object(s)

        These arguments will usually be one or more regions that were changed.
        An argument of "None" indicates either creation or deletion.
        """
        self.oldState = oldState
        self.newState = newState
# end of class Action


class Point:
    def __init__(self, x, y):
        """Create an object that allows floating point vector operations.

        x - Float, first coordinate of point
        y - Float, second coordinate of point
        """
        if isinstance(x, float) and isinstance(y, float):
            self.x = x
            self.y = y
        else:
            raise TypeError('\'Point\' creation takes only \'float\' values')

    def __str__(self):
        """Representation of object."""
        return '(%.3f\t%.3f)' % (self.x, self.y)

    def __hash__(self):
        """Hashtable representation of object."""
        tup = (self.x, self.y)
        return tup.__hash__()

    def __eq__(self, other):
        """Checks equality (self == other)."""
        return isinstance(other, Point) and self.x == other.x and self.y == other.y

    def __ne__(self, other):
        """Checks non-equality (self != other)."""
        return not self.__eq__(other)

    def __add__(self, other):
        """Addition operator (self + other)."""
        if isinstance(other, Point):
            return Point(self.x + other.x, self.y + other.y)
        elif isinstance(other, tuple) and len(other) == 2:
            return Point(self.x + other[0], self.y + other[1])
        else:
            raise TypeError('cannot add \'Point\' and \'' + \
                other.__class__.__name__ + '\' objects')

    def __radd__(self, other):
        """Right addition operator (other + self)."""
        return self.__add__(other)

    def __sub__(self, other):
        """Subtraction operator (self - other)."""
        if isinstance(other, Point):
            return Point(self.x - other.x, self.y - other.y)
        elif isinstance(other, tuple) and len(other) == 2:
            return Point(self.x - other[0], self.y - other[1])
        else:
            raise TypeError('cannot subtract \'Point\' and \'' + \
                other.__class__.__name__ + '\' objects')

    def __rsub__(self, other):
        """Right subtraction operator (other - self)."""
        if isinstance(other, Point):
            return Point(other.x - self.x, other.y - self.y)
        elif isinstance(other, tuple) and len(other) == 2:
            return Point(other[0] - self.x, other[1] - self.y)
        else:
            raise TypeError('cannot subtract \'Point\' and \'' + \
                other.__class__.__name__ + '\' objects')

    def __mul__(self, other):
        """Multiplication operator (self * other)."""
        if isinstance(other, float):
            return Point(self.x * other, self.y * other)
        else:
            raise TypeError('cannot multiply \'Point\' and \'' + \
                other.__class__.__name__ + '\' objects')

    def __rmul__(self, other):
        """Right multiplication operator (other * self)."""
        return self.__mul__(other)

    def __div__(self, other):
        """Division operator (self / other)."""
        if isinstance(other, float):
            return Point(self.x / other, self.y / other)
        else:
            raise TypeError('cannot divide \'Point\' and \'' + \
                other.__class__.__name__ + '\' objects')

    def __truediv__(self, other):
        """True division operator."""
        return self.__div__(other)

    def Dot(self, other):
        """Dot product."""
        if isinstance(other, Point):
            return self.x * other.x + self.y * other.y
        elif isinstance(other, tuple) and len(other) == 2:
            return self.x * other[0] + self.y * other[1]
        else:
            raise TypeError('cannot compute dot product of \'Point\' and \'' + \
                other.__class__.__name__ + '\' object')

    def Dist(self, other):
        """Euclidean distance from this point to the other."""
        if isinstance(other, Point):
            return math.sqrt((self.x - other.x) ** 2 + \
                (self.y - other.y) ** 2)
        elif isinstance(other, tuple) and len(other) == 2:
            return math.sqrt((self.x - other[0]) ** 2 + \
                (self.y - other[1]) ** 2)
        else:
            raise TypeError('cannot compute distance from \'Point\' to \'' + \
                other.__class__.__name__ + '\' object')

    def Norm(self):
        """Length of the vector."""
        return math.sqrt(self.x ** 2 + self.y ** 2)
# end of class Point


class ViconMarkerListener(threading.Thread):
    def __init__(self, parent):
        """Create the a socket to receive Vicon data."""
        super(ViconMarkerListener, self).__init__()

        # Communication parameters
        self.parent = parent        # RegionEditor GUI
        self.addr = ("0.0.0.0", 7500)
        self.bufsize = 65536
        self.udpSock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.lock = threading.Lock()
        self.close = threading.Event()
        self.updateFreq = 20    # Hz

        # Tracking parameters
        # TODO: Set all paremeters in configuration of GUI
        self.minDist = 0.01     # Distance to move to qualify as movement
        self.maxDist = 0.1      # Qualified as new point
        self.movMaxTime = 15 * self.updateFreq  # (sec)*(Hz)
                                # Iterations during which marker is not moving
                                # before stopping tracking
        self.invMaxTime = 1 * self.updateFreq   # (sec)*(Hz)
                                # Iterations during which marker is not found
                                # before stopping tracking

        # Tracking containers
        self.oldPoses = []      # Previous marker positions
        self.movingPoses = []   # Markers that are moving
        self.movingTimeout = [] # Iterations left before movement timeout
        self.invisTimeout = []  # Iteractions left before not-found timeout

    def run(self):
        """Open the socket to start communication. Process messages."""
        # Open socket for communication
        self.udpSock.bind(self.addr)

        # Receive communication until stopped
        self.close.clear()
        delay = 1 / self.updateFreq
        while not self.close.isSet():
            self.lock.acquire()
            data = self.udpSock.recv(self.bufsize)
            self.lock.release()
            self.ProcessData(data)
            time.sleep(delay)

        # Close socket
        self.udpSock.close()
        self.oldPoses = []
        self.movingPoses = []
        self.movingTimeout = []
        self.invisTimeout = []

    def stop(self):
        """Close the socket to end UDP communication."""
        self.close.set()

    # Deserialize and save data
    def ProcessData(self, data):
        """Extract marker positions and pass them on to be mapped.

        data - Byte array encoded from multiple pairs of doubles [x1 y1 ...]
        """
        # Check for valid data (not null or incomplete)
        if data and len(data)%16 == 0:
            poses = []
            for i in range(0, len(data), 16):
                x, y = struct.unpack('dd', data[i:i+16])
                poses.append(Point(x, y))
            # Save and plot marker positions
            self.parent.markerPoses = poses
            self.UpdateMovingMarkers(poses)
            self.parent.RedrawCanvas()      # Force map redraw

    def UpdateMovingMarkers(self, poses):
        """Note which markers are newly moving and update position of old
        moving markers based on change in position from previous list.

        poses - List of Points, marker positions.
        """
        # Not first time through
        if self.oldPoses:
            # Check all currently tracked markers first
            for iMarker, markerPose in enumerate(self.movingPoses):
                closestIdx = self.FindClosest(poses, markerPose)
                closestDist = markerPose.Dist(poses[closestIdx])
                # Same marker
                if closestDist < self.maxDist:
                    self.invisTimeout[iMarker] = self.invMaxTime
                    # Is moving
                    if closestDist > self.minDist:
                        self.movingTimeout[iMarker] = self.movMaxTime + 1
                    self.movingPoses[iMarker] = poses[closestIdx]
                # Marker not seen
                else:
                    self.invisTimeout[iMarker] -= 1
                self.movingTimeout[iMarker] -= 1
                # Marker has stopped moving or not been seen for some time
                if self.invisTimeout[iMarker] == 0 or \
                        self.movingTimeout[iMarker] == 0:
                    self.invisTimeout.pop(iMarker)
                    self.movingTimeout.pop(iMarker)
                    self.movingPoses.pop(iMarker)
            # Check through all new markers next
            for markerPose in poses:
                closestIdx = self.FindClosest(self.oldPoses, markerPose)
                closestDist = markerPose.Dist(self.oldPoses[closestIdx])
                # Point is moving
                if closestDist < self.maxDist and closestDist > self.minDist:
                    self.movingPoses.append(markerPose)
                    self.movingTimeout.append(self.movMaxTime)
                    self.invisTimeout.append(self.invMaxTime)
        self.oldPoses = poses

    def FindClosest(self, points, target):
        """Find the closest point to the target.

        points - List of Points, marker positions.
        target - Point, point to find marker closest to.
        returns - Integer, index of closest point in points.
        """
        # Iterate through all points
        minDist = float('inf')
        minIdx = 0
        for i, pt in enumerate(points):
            dist = target.Dist(pt)
            if dist < minDist:
                minIdx = i
                minDist = dist
        return minIdx
# end of class ViconMarkerListener


class AudioFeedbackThread(threading.Thread):
    def __init__(self, feedbackDialog, regEditor):
        """Create audio feedback for marker placement.

        fbDia - Dialog box that specifies the point of interest.
        regEd - RegionEditor GUI that gets Vicon information.
        """
        super(AudioFeedbackThread, self).__init__()

        # Save other objects
        self.fbDia = feedbackDialog
        self.regEd = regEditor
        
        # Non-audio parameters
        self.close = threading.Event()
        self.tolerance = 0.10   # Close-enough distance (m)
        self.maxDist = 2.5      # Points must be within this to react (m)

        # Audio parameters for beeping
        # Chosen for audibility at distance
        # TODO: Make modifiable by configuration file
        minFreq = 600           # Lowest frequency played (Hz)
        maxFreq = 7000          # Highest frequency played (Hz)
        updateFreq = 2.0        # Frequency of possible sound change (Hz)
        self.duration = int(1000.0 / updateFreq)
        
        # Audio parameters for text-to-speech
        self.engine = pyttsx.init()
        self.engine.setProperty('rate', 120)
        self.engine.setProperty('volume', 1.0)
        self.speechFormat = "X %.1f, Y %.1f"
        self.speechPause = 1.0  # Pause between voice commands

        # Calculate the line representing the distance-frequency mapping
        self.freqSlope = (minFreq - maxFreq) / (self.maxDist - self.tolerance)
        self.freqIntercept = maxFreq - self.tolerance * self.freqSlope

    def run(self):
        """Play sound based on distance of moving marker to goal point."""
        self.close.clear()
        while not self.close.isSet():
            soundOption = self.fbDia.radioboxOption.GetSelection()
            if not self.fbDia.chkbxMute.GetValue():
                # Get distance from closest marker to point of interest
                intPt = self.regEd.regions[self.fbDia.currReg].\
                    verts[self.fbDia.currPt]
                minStatDistToPt = 2.0 * self.maxDist
                for statPt in self.regEd.markerPoses:
                    if not statPt in self.regEd.viconListener.movingPoses:
                        minStatDistToPt = min(minStatDistToPt, intPt.Dist(statPt))

                # Get distance from closest moving point to point of interest
                minDistToPt = 2.0 * self.maxDist
                minPtIdx = -1
                for iPt, movPt in \
                        enumerate(self.regEd.viconListener.movingPoses):
                    dist = intPt.Dist(movPt)
                    if dist < minDistToPt:
                        minDistToPt = dist
                        minPtIdx = iPt

                # Plot moving point and goal point
                dc = wx.WindowDC(self.regEd.canvas)
                dc.SetBrush(wx.Brush(wx.Colour(255, 0, 0, 100), wx.SOLID))
                posePix = self.regEd.Map2Pix(intPt)
                dc.DrawCircle(posePix[0], posePix[1], 8)
                if minPtIdx > -1 and minPtIdx < \
                        len(self.regEd.viconListener.movingPoses):
                    posePix = self.regEd.Map2Pix(\
                        self.regEd.viconListener.movingPoses[minPtIdx])
                    dc.DrawCircle(posePix[0], posePix[1], 8)

                # Close-enough
                if minDistToPt < self.tolerance or \
                        minStatDistToPt < self.tolerance:
                    # Marker is settled
                    if minStatDistToPt < self.tolerance or self.regEd.\
                            viconListener.movingTimeout[minPtIdx] < \
                            self.regEd.viconListener.movMaxTime:
                        # Play "success" sound to indicate done with point
                        if soundOption:
                            time.sleep(0.2)
                            winsound.Beep(600, 200)
                            winsound.Beep(1200, 200)
                            winsound.Beep(1800, 200)
                            time.sleep(0.2)
                        else:
                            self.engine.say("Success, next")
                            self.engine.runAndWait()
                            time.sleep(self.speechPause)
                        # Switch to next point of interest if checked
                        if self.fbDia.chkbxIterate.GetValue():
                            self.fbDia.OnButtonNext(None)
                            # TODO: Check if all points are in correct spots
                            #       and stop if done

                    # Marker not yet settled
                    else:
                        # Play "good" sound to signal "stop moving marker"
                        if soundOption:
                            time.sleep(0.2)
                            winsound.Beep(1200, 200)
                            winsound.Beep(1200, 200)
                            time.sleep(0.2)
                        else:
                            self.engine.say("Stop there")
                            self.engine.runAndWait()
                            time.sleep(self.speechPause)
                
                # Still within distance of effect
                elif minDistToPt < self.maxDist:
                    if soundOption:
                        freq = int(self.freqIntercept + self.freqSlope * \
                            minDistToPt)
                        winsound.Beep(freq, self.duration)
                    else:
                        diffPt = intPt - self.regEd.viconListener.\
                            movingPoses[minPtIdx]
                        self.engine.say(self.speechFormat % \
                            (diffPt.x, diffPt.y))
                        self.engine.runAndWait()
                        time.sleep(self.speechPause)

    def stop(self):
        """Signal for the thread to end."""
        self.engine.stop()
        self.close.set()


if __name__ == "__main__":
    app = wx.PySimpleApp(0)
    wx.InitAllImageHandlers()
    if len(sys.argv) > 1:
        regEd = regionEditor(None, -1, sys.argv[1])
    else:
        regEd = regionEditor(None, -1)
    app.SetTopWindow(regEd)
    app.MainLoop()
