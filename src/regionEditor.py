#!/usr/bin/env python
# -*- coding: iso-8859-15 -*-
# generated by wxGlade 0.6.5 (standalone edition) on Mon Feb 13 13:09:57 2012

import os
import sys
import collections
import time
import math
import numpy
import wx
import threading
import socket
import struct
import copy
import random
import re
import winsound
import pyttsx
import lib.fileMethods as fileMethods
import json
from lib.regions import prettierJSONEncoder
import lib._transformations as _transformations

# begin wxGlade: extracode
# end wxGlade

class regionEditor(wx.Frame):
    def __init__(self, *args, **kwds):
        # begin wxGlade: regionEditor.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        
        # Menu Bar
        self.RegionEditor_menubar = wx.MenuBar()
        self.filemenu = wx.Menu()
        self.menuNew = wx.MenuItem(self.filemenu, wx.NewId(), "New", "", wx.ITEM_NORMAL)
        self.filemenu.AppendItem(self.menuNew)
        self.menuOpen = wx.MenuItem(self.filemenu, wx.NewId(), "Open", "", wx.ITEM_NORMAL)
        self.filemenu.AppendItem(self.menuOpen)
        self.menuSave = wx.MenuItem(self.filemenu, wx.NewId(), "Save", "", wx.ITEM_NORMAL)
        self.filemenu.AppendItem(self.menuSave)
        self.menuSaveAs = wx.MenuItem(self.filemenu, wx.NewId(), "Save As", "", wx.ITEM_NORMAL)
        self.filemenu.AppendItem(self.menuSaveAs)
        self.menuExit = wx.MenuItem(self.filemenu, wx.NewId(), "Exit", "", wx.ITEM_NORMAL)
        self.filemenu.AppendItem(self.menuExit)
        self.RegionEditor_menubar.Append(self.filemenu, "File")
        self.menuEdit = wx.Menu()
        self.menuUndo = wx.MenuItem(self.menuEdit, wx.NewId(), "Undo", "", wx.ITEM_NORMAL)
        self.menuEdit.AppendItem(self.menuUndo)
        self.menuRedo = wx.MenuItem(self.menuEdit, wx.NewId(), "Redo", "", wx.ITEM_NORMAL)
        self.menuEdit.AppendItem(self.menuRedo)
        self.RegionEditor_menubar.Append(self.menuEdit, "Edit")
        self.menuDrawing = wx.Menu()
        self.menuAutobound = wx.MenuItem(self.menuDrawing, wx.NewId(), "Autoboundary", "", wx.ITEM_NORMAL)
        self.menuDrawing.AppendItem(self.menuAutobound)
        self.menuRect = wx.MenuItem(self.menuDrawing, wx.NewId(), "Rectangle", "", wx.ITEM_NORMAL)
        self.menuDrawing.AppendItem(self.menuRect)
        self.menuPoly = wx.MenuItem(self.menuDrawing, wx.NewId(), "Polygon", "", wx.ITEM_NORMAL)
        self.menuDrawing.AppendItem(self.menuPoly)
        self.menuAddPoint = wx.MenuItem(self.menuDrawing, wx.NewId(), "Add Point", "", wx.ITEM_NORMAL)
        self.menuDrawing.AppendItem(self.menuAddPoint)
        self.menuRemPoint = wx.MenuItem(self.menuDrawing, wx.NewId(), "Remove Point", "", wx.ITEM_NORMAL)
        self.menuDrawing.AppendItem(self.menuRemPoint)
        self.RegionEditor_menubar.Append(self.menuDrawing, "Drawing")
        self.menuView = wx.Menu()
        self.menuMarkers = wx.MenuItem(self.menuView, wx.NewId(), "Markers", "", wx.ITEM_CHECK)
        self.menuView.AppendItem(self.menuMarkers)
        self.menuMarkersClear = wx.MenuItem(self.menuView, wx.NewId(), "Clear Markers", "", wx.ITEM_NORMAL)
        self.menuView.AppendItem(self.menuMarkersClear)
        self.menuCamera = wx.MenuItem(self.menuView, wx.NewId(), "Camera Capture", "", wx.ITEM_NORMAL)
        self.menuView.AppendItem(self.menuCamera)
        self.menuImageImport = wx.MenuItem(self.menuView, wx.NewId(), "Import Background Image", "", wx.ITEM_NORMAL)
        self.menuView.AppendItem(self.menuImageImport)
        self.menuImageClear = wx.MenuItem(self.menuView, wx.NewId(), "Clear Background Image", "", wx.ITEM_NORMAL)
        self.menuView.AppendItem(self.menuImageClear)
        self.RegionEditor_menubar.Append(self.menuView, "View")
        self.helpmenu = wx.Menu()
        self.menuAbout = wx.MenuItem(self.helpmenu, wx.NewId(), "About", "", wx.ITEM_NORMAL)
        self.helpmenu.AppendItem(self.menuAbout)
        self.RegionEditor_menubar.Append(self.helpmenu, "Help")
        self.SetMenuBar(self.RegionEditor_menubar)
        # Menu Bar end
        self.sidebar = wx.Panel(self, -1)
        self.toggleVicon = wx.ToggleButton(self.sidebar, -1, "Vicon")
        self.buttonCamera = wx.Button(self.sidebar, -1, "Camera")
        self.toggleSquare = wx.ToggleButton(self.sidebar, -1, "Rect.")
        self.togglePoly = wx.ToggleButton(self.sidebar, -1, "Polygon")
        self.toggleDim = wx.ToggleButton(self.sidebar, -1, "Length")
        self.buttonAutobound = wx.Button(self.sidebar, -1, "Boundary")
        self.toggleFeedback = wx.ToggleButton(self.sidebar, -1, "Feedback")
        self.buttonCal = wx.Button(self.sidebar, -1, "Calibrate")
        self.canvas = wx.Panel(self, -1, style=wx.SUNKEN_BORDER | wx.TAB_TRAVERSAL)

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_MENU, self.OnMenuNew, self.menuNew)
        self.Bind(wx.EVT_MENU, self.OnMenuOpen, self.menuOpen)
        self.Bind(wx.EVT_MENU, self.OnMenuSave, self.menuSave)
        self.Bind(wx.EVT_MENU, self.OnMenuSaveAs, self.menuSaveAs)
        self.Bind(wx.EVT_MENU, self.OnMenuExit, self.menuExit)
        self.Bind(wx.EVT_MENU, self.OnMenuUndo, self.menuUndo)
        self.Bind(wx.EVT_MENU, self.OnMenuRedo, self.menuRedo)
        self.Bind(wx.EVT_MENU, self.OnMenuAutobound, self.menuAutobound)
        self.Bind(wx.EVT_MENU, self.OnMenuRect, self.menuRect)
        self.Bind(wx.EVT_MENU, self.OnMenuPoly, self.menuPoly)
        self.Bind(wx.EVT_MENU, self.OnMenuAddPoint, self.menuAddPoint)
        self.Bind(wx.EVT_MENU, self.OnMenuRemPoint, self.menuRemPoint)
        self.Bind(wx.EVT_MENU, self.OnMenuMarkers, self.menuMarkers)
        self.Bind(wx.EVT_MENU, self.OnMenuMarkersClear, self.menuMarkersClear)
        self.Bind(wx.EVT_MENU, self.OnMenuCamera, self.menuCamera)
        self.Bind(wx.EVT_MENU, self.OnMenuImageImport, self.menuImageImport)
        self.Bind(wx.EVT_MENU, self.OnMenuImageClear, self.menuImageClear)
        self.Bind(wx.EVT_MENU, self.OnMenuAbout, self.menuAbout)
        self.Bind(wx.EVT_TOGGLEBUTTON, self.OnToggleVicon, self.toggleVicon)
        self.Bind(wx.EVT_BUTTON, self.OnButtonCamera, self.buttonCamera)
        self.Bind(wx.EVT_TOGGLEBUTTON, self.OnToggleSquare, self.toggleSquare)
        self.Bind(wx.EVT_TOGGLEBUTTON, self.OnTogglePoly, self.togglePoly)
        self.Bind(wx.EVT_TOGGLEBUTTON, self.OnToggleDim, self.toggleDim)
        self.Bind(wx.EVT_BUTTON, self.OnButtonAutobound, self.buttonAutobound)
        self.Bind(wx.EVT_TOGGLEBUTTON, self.OnToggleFeedback, self.toggleFeedback)
        self.Bind(wx.EVT_BUTTON, self.OnButtonCal, self.buttonCal)
        # end wxGlade
        
        # Handle input
        if len(args) > 2 and isinstance(args[2], str):
            self.fileName = os.path.join(os.getcwd(), args[2])
        else:
            self.fileName = ""
        
        # Bind mouse events
        self.canvas.Bind(wx.EVT_LEFT_DOWN, self.OnMouseLeftDown, self.canvas)
        self.canvas.Bind(wx.EVT_LEFT_UP, self.OnMouseLeftUp, self.canvas)
        self.canvas.Bind(wx.EVT_LEFT_DCLICK, self.OnMouseLeftDClick, self.canvas)
        self.canvas.Bind(wx.EVT_RIGHT_DOWN, self.OnMouseRightDown, self.canvas)
        self.canvas.Bind(wx.EVT_RIGHT_UP, self.OnMouseRightUp, self.canvas)
        self.canvas.Bind(wx.EVT_MOUSEWHEEL, self.OnMouseWheel, self.canvas)
        self.canvas.Bind(wx.EVT_ENTER_WINDOW, self.OnEnterWindow, self.canvas)
        self.canvas.Bind(wx.EVT_LEAVE_WINDOW, self.OnLeaveWindow, self.canvas)
        
        # Bind keyboard events
        self.Bind(wx.EVT_KEY_DOWN, self.OnKeyDown, self)
        self.canvas.Bind(wx.EVT_KEY_DOWN, self.OnKeyDown, self.canvas)
        
        # Determine mapping of the canvas panel to the field
        canvasLen = self.canvas.GetSize()       # Initial size of canvas (pixels)
        fieldRange = [(-3.0, 9.0), (-3.0, 3.0)] # Initial range of field (m)
                                                # [(xmin, xmax), (ymin, ymax)]
        # pose = pixPose * scale + offset
        # Note: y-pixels and y-pose have opposite directions
        xScale = (fieldRange[0][1] - fieldRange[0][0]) / float(canvasLen[0])
        xOffset = fieldRange[0][0]
        yScale = -(fieldRange[1][1] - fieldRange[1][0]) / float(canvasLen[1])
        yOffset = -fieldRange[1][0]
        self.canvasScale = Point(xScale, yScale)
        self.canvasOffset = Point(xOffset, yOffset)
        
        # Region-related parameters
        self.regions = []                   # List of regions in the map
        self.adjacent = []                  # List of lists holding transition
                                            # edges between regions.
                                            # adjacent[i][j] contains a list of
                                            # indices of edges in region i that
                                            # connect to edges in region j.
                                            # adjacent[j][i] should contain a
                                            # list of the same length, but edge
                                            # indices are for region j.
                                            # adjacent[i][i] will be empty.
        self.polyVerts = []                 # Keeps points for region creation
                                            # and dimensioning
                                            # Region creation: [Point(x0,y0), ...]
                                            # Dimensioning: (idxRegion, idxVert)
        
        # Mouse-related parameters
        self.leftClickPt = Point(0.0, 0.0)  # Location of last left downclick
        self.rightClickPt = Point(0.0, 0.0) # Location of last right downclick
        self.justDoubleClicked = False      # Indicating double-click event
        self.tolerance = 5.0 * xScale       # Distance to consider as "same point" (m)
        # TODO: Make tolerance a parameter on pixels only
        #       Calculate "same point" with scale later
        self.selectedRegions = []           # List of currently selected regions
        
        # Set up for undo/redo capabilities
        # TODO: Disable self.menuUndo and self.menuRedo
        self.unredoBufLen = 50
        self.undoActions = collections.deque()
        self.redoActions = collections.deque()
        
        # Add paint event handler to draw on the canvas
        # TODO: Fix problems here
        #self.canvas.Bind(wx.EVT_PAINT, self.OnCanvasPaint)
        
        # Create Vicon listener
        self.markerPoses = []   # Marker positions to be drawn
        self.viconListener = ViconMarkerListener(self)
        self.dlgFeedback = None
        
        # Add close event handler to cleanup and possibly save before closing
        self.Bind(wx.EVT_CLOSE, self.OnClose)
        
        # Display the GUI window and set up the map canvas
        self.Show()
        self.DrawGrid()
    
    def __set_properties(self):
        # begin wxGlade: regionEditor.__set_properties
        self.SetTitle("Region Editor")
        self.toggleVicon.SetMinSize((50, 50))
        self.buttonCamera.SetMinSize((50, 50))
        self.toggleSquare.SetMinSize((50, 50))
        self.togglePoly.SetMinSize((50, 50))
        self.toggleDim.SetMinSize((50, 50))
        self.buttonAutobound.SetMinSize((50, 50))
        self.toggleFeedback.SetMinSize((50, 50))
        self.buttonCal.SetMinSize((50, 50))
        self.sidebar.SetMinSize((120, 400))
        self.canvas.SetMinSize((800, 400))
        self.canvas.SetBackgroundColour(wx.Colour(255, 255, 255))
        # end wxGlade
    
    def __do_layout(self):
        # begin wxGlade: regionEditor.__do_layout
        sizer_1 = wx.BoxSizer(wx.HORIZONTAL)
        grid_sizer_1 = wx.GridSizer(4, 2, 5, 5)
        grid_sizer_1.Add(self.toggleVicon, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        grid_sizer_1.Add(self.buttonCamera, 1, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        grid_sizer_1.Add(self.toggleSquare, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        grid_sizer_1.Add(self.togglePoly, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        grid_sizer_1.Add(self.toggleDim, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        grid_sizer_1.Add(self.buttonAutobound, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        grid_sizer_1.Add(self.toggleFeedback, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        grid_sizer_1.Add(self.buttonCal, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        self.sidebar.SetSizer(grid_sizer_1)
        sizer_1.Add(self.sidebar, 0, wx.EXPAND, 0)
        sizer_1.Add(self.canvas, 1, wx.EXPAND, 0)
        self.SetSizer(sizer_1)
        sizer_1.Fit(self)
        self.Layout()
        # end wxGlade
    
    def OnClose(self, event):
        """Perform cleanup tasks and close the application."""
        # Check if the closure can even be canceled
        # TODO: Check if map is unsaved and ask if they want to save before closing
        if not event or event.CanVeto():
            dlg = wx.MessageDialog(self,
                "Do you really want to close this application?",
                "Confirm Exit", wx.OK|wx.CANCEL|wx.ICON_QUESTION)
            result = dlg.ShowModal()
            dlg.Destroy()
            if result == wx.ID_OK:
                self.viconListener.stop()
                # TODO: Check if vicon is indeed running, and put wait-notify
                #       in to close port before closing GUI
                self.Destroy()
        else:
            self.viconListener.stop()
            self.Destroy()
    
    def OnToggleVicon(self, event):  # wxGlade: regionEditor.<event_handler>
        # Switch Vicon streaming on or off based on state of toggle button
        if self.toggleVicon.GetValue():
            self.viconListener.start()
            
            # TODO: Add while loop to wait for data to come in
            #       If it times out print message
            #       If data comes in, zoom out to ensure all markers seen
        else:
            self.viconListener.stop()
            # Reinitialize thread to enable restarting it
            self.viconListener = ViconMarkerListener(self)
    
    def OnButtonCamera(self, event):  # wxGlade: regionEditor.<event_handler>
        print "Camera not yet implemented"
        # TODO
        event.Skip()
    
    def OnToggleSquare(self, event):  # wxGlade: regionEditor.<event_handler>
        self.ResetMapToggles(self.toggleSquare)
    
    def OnTogglePoly(self, event):  # wxGlade: regionEditor.<event_handler>
        self.ResetMapToggles(self.togglePoly)
    
    def OnToggleDim(self, event):  # wxGlade: regionEditor.<event_handler>
        self.ResetMapToggles(self.toggleDim)
    
    def OnButtonAutobound(self, event):  # wxGlade: regionEditor.<event_handler>
        self.AddToUndo()
        self.Autoboundary()
        self.RedrawCanvas()
    
    def OnToggleFeedback(self, event):  # wxGlade: regionEditor.<event_handler>
        self.ResetMapToggles(self.toggleFeedback)
        if self.toggleFeedback.GetValue():
            self.dlgFeedback = FeedbackDialog(self)
            self.dlgFeedback.ShowModal()
        elif self.dlgFeedback:
            self.dlgFeedback.OnClose(None)
    
    def OnButtonCal(self, event):  # wxGlade: regionEditor.<event_handler>
        self.ResetMapToggles()
        self.AddToUndo()
        calibGUI = CalibrationFrame(self)
    
    def OnMenuNew(self, event):  # wxGlade: regionEditor.<event_handler>
        self.AddToUndo()
        self.ResetMapToggles()
        self.regions = []
        self.adjacent = []
        # TODO: Clear background image
        self.RedrawCanvas()
    
    def OnMenuOpen(self, event):  # wxGlade: regionEditor.<event_handler>
        # Start up open dialog
        dialogOpen = wx.FileDialog(self, message="Open File", \
            defaultDir=sys.path[0], \
            defaultFile=self.fileName.split('\\').pop(), \
            wildcard="*.regions", style=wx.FD_OPEN)
        
        # Hit Open
        if dialogOpen.ShowModal() == wx.ID_OK:
            self.AddToUndo()
            filePath = dialogOpen.GetPath()
            if not os.path.exists(filePath) or not ('.regions' in filePath):
                return
            
            # Pull all data from file into dictionary for parsing
            data = fileMethods.readFromFile(filePath)
            
            if data is None:
                return
            
            # Clear all current information
            self.regions = []
            self.adjacent = []
            # self.bkgndImage = None
            
            # TODO: Uncomment when background image is included
            #try:
            #    self.bkgndImage = data["Background"][0]
            #except KeyError:
            #    self.bkgndImage = None
            
            # Set all region information from lines in file
            rdata = json.loads("\n".join(data["Regions"]))
            for rd in rdata:
                newRegion = Region()
                newRegion.setData(rd)
                self.regions.append(newRegion)

            # Make an empty adjacency matrix of size (nRegions) x (nRegions)
            self.adjacent = [[[] for j in range(len(self.regions))] \
                for i in range(len(self.regions))]
            
            # Assign region transitions
            # Each transition line format is this:
            # Region1Idx Region2Idx [(Reg1FaceIdx1 Reg2FaceIdx1) (Reg1FaceIdx2 Reg2FaceIdx2) ...]
            for tData in data["Transitions"]:
                tData = re.sub('[\[\]\(\)]', '', tData)
                tData = tData.split();      # Separate on any whitespace
                iReg1 = self.indexOfRegionWithName(tData[0])
                iReg2 = self.indexOfRegionWithName(tData[1])
                # All transitions between regions
                for i in range(2, len(transData), 2):
                    iFaceReg1 = int(tData[i])
                    iFaceReg2 = int(tData[i+1])
                    self.adjacent[iReg1][iReg2].append((iFaceReg1, iFaceReg2))
                    # Don't assume bidirectional transitions
                    # Region file will specify both directions if bidirectional
                    
            # Set "obstacleness" of regions
            if "Obstacles" in data:
                for regName in data["Obstacles"]:
                    self.regions[self.indexOfRegionWithName( \
                        regName)].isObstacle = True
            
            # Store the filename for saving
            self.fileName = filePath
        
        # TODO: Rescale/pan map to bring full map into view
        self.RedrawCanvas()
        
        dialogOpen.Destroy()
    
    def OnMenuSave(self, event):  # wxGlade: regionEditor.<event_handler>
        """Save to file that has already been used."""
        # Filename known
        if self.fileName:
            # Bring up dialog box to ask about boundary if necessary
            if self.regions and not self.ExistBoundary():
                msg = "No boundary found. Automatically create rectangular boundary?"
                boundDialog = wx.MessageDialog(self, msg, style=wx.YES_NO|wx.CANCEL|\
                    wx.YES_DEFAULT|wx.ICON_EXCLAMATION|wx.STAY_ON_TOP)
                boundDiaResult = boundDialog.ShowModal()
                if boundDiaResult == wx.ID_YES:
                    self.Autoboundary()
                elif boundDiaResult == wx.ID_CANCEL:
                    return
            
            comments = {"FILE_HEADER":"This is a region definition file for " +
                                      "the LTLMoP toolkit.\nFormat details " +
                                      "are described at the beginning of " +
                                      "each section below.\n",
                        "Background": "Relative path of background image file",
                        "Regions": "Stored as JSON string",
                        "Transitions": "reg1name reg2name " + 
                                       "[(reg1face1idx reg2face1idx) " +
                                       "(reg1face2idx reg2face2idx) ...]",
                        "Obstacles": "Names of regions to treat as obstacles"}
            
            regionData = []
            for r in self.regions:
                d = r.getData()
                # Don't store the following attribute inside the regions
                del d['isObstacle']
                regionData.append(d)
            je = prettierJSONEncoder(indent=4)
            regionData = [je.encode(regionData)]
            
            transitionData = []
            for iReg1, destinations in enumerate(self.adjacent):
                # Note: Don't assume bi-directional transitions
                for iReg2, faces in enumerate(destinations):
                    if faces == []: continue    # No transitions so skip
                    
                    singleTrans = self.regions[iReg1].name + "\t" + \
                        self.regions[iReg2].name + "\t["
                    for face in faces:
                        singleTrans += "(" + str(face[0]) + "\t" + \
                            str(face[1]) + ")"
                    transitionData.append(singleTrans)
            
            obstacleRegions = [r.name for r in self.regions if r.isObstacle]
            
            # TODO: Get background image in here
            data = {"Regions": regionData,
                    "Transitions": transitionData,
                    "Obstacles": obstacleRegions}

            fileMethods.writeToFile(self.fileName, data, comments)
        
        # No known filename
        else:
            self.OnMenuSaveAs(None)
    
    def OnMenuSaveAs(self, event):  # wxGlade: regionEditor.<event_handler>
        dialogSave = wx.FileDialog(self, message="Save File As", \
            defaultDir=sys.path[0], \
            defaultFile=self.fileName.split('\\').pop(), \
            wildcard="*.regions", style=wx.FD_SAVE|wx.FD_OVERWRITE_PROMPT)
        # Hit Save and confirmed overwrite if necessary
        if dialogSave.ShowModal() == wx.ID_OK:
            self.fileName = dialogSave.GetPath()
            self.OnMenuSave(None)
        dialogSave.Destroy()

    def OnMenuExit(self, event):  # wxGlade: regionEditor.<event_handler>
        self.OnClose(None)

    def OnMenuUndo(self, event):  # wxGlade: regionEditor.<event_handler>
        """Revert the most recent undoable change."""
        # Currently drawing polygon
        # Note that this is not a redoable action by design
        if self.polyVerts:
            self.polyVerts = []
            self.RedrawCanvas()
        # Other undoable changes exist
        elif self.undoActions:
            # Save current state to redo
            newAction = Action(self.regions, self.adjacent)
            self.redoActions.append(newAction)
            
            # Undo action
            action = self.undoActions.pop()
            self.regions = action.stateRegions
            self.adjacent = action.stateAdjacent
            # TODO: if not self.undoActions: disable self.menuUndo
            # TODO: enable self.menuRedo
            self.RedrawCanvas()

    def OnMenuRedo(self, event):  # wxGlade: regionEditor.<event_handler>
        """Reapply most recently undone action."""
        # Redoable actions exist
        if self.redoActions:
            # Save current state to undo
            newAction = Action(self.regions, self.adjacent)
            self.undoActions.append(newAction)
            
            # Redo action
            action = self.redoActions.pop()
            self.regions = action.stateRegions
            self.adjacent = action.stateAdjacent
            # TODO: if not self.redoActions: disable self.menuRedo
            # TODO: enable self.menuUndo
            self.RedrawCanvas()

    def OnMenuAutobound(self, event):  # wxGlade: regionEditor.<event_handler>
        self.AddToUndo()
        self.Autoboundary()
        self.RedrawCanvas()

    def OnMenuRect(self, event):  # wxGlade: regionEditor.<event_handler>
        self.toggleSquare.SetValue(True)
        self.OnToggleSquare(None)

    def OnMenuPoly(self, event):  # wxGlade: regionEditor.<event_handler>
        self.togglePoly.SetValue(True)
        self.OnTogglePoly(None)

    def OnMenuAddPoint(self, event):  # wxGlade: regionEditor.<event_handler>
        print "Event handler `OnMenuAddPoint' not implemented"
        event.Skip()

    def OnMenuRemPoint(self, event):  # wxGlade: regionEditor.<event_handler>
        print "Event handler `OnMenuRemPoint' not implemented"
        event.Skip()

    def OnMenuMarkers(self, event):  # wxGlade: regionEditor.<event_handler>
        print "Event handler `OnMenuMarkers' not implemented"
        event.Skip()

    def OnMenuMarkersClear(self, event):  # wxGlade: regionEditor.<event_handler>
        self.markerPoses = []
        self.RedrawCanvas()

    def OnMenuCamera(self, event):  # wxGlade: regionEditor.<event_handler>
        print "Event handler `OnMenuCamera' not implemented"
        event.Skip()

    def OnMenuImageImport(self, event):  # wxGlade: regionEditor.<event_handler>
        print "Event handler `OnMenuImageImport' not implemented"
        event.Skip()

    def OnMenuImageClear(self, event):  # wxGlade: regionEditor.<event_handler>
        print "Event handler `OnMenuImageClear' not implemented"
        event.Skip()
    
    def OnMenuAbout(self, event):  # wxGlade: regionEditor.<event_handler>
        print "About not yet implemented"
        event.Skip()

    def OnMouseLeftDown(self, event):
        """Save the left click point so it can be used later."""
        self.leftClickPt, iReg, iPt, iEd = \
            self.SnapPoint(self.Pix2Map(event.GetPosition()))

    def OnMouseLeftUp(self, event):
        """Perform appropriate action based on current mode of operation."""
        # Get click position
        ptPix = event.GetPosition()
        pt, iReg, iPt, iEd = self.SnapPoint(self.Pix2Map(ptPix))
        
        # Has been handled by double-click event handler
        if self.justDoubleClicked:
            self.justDoubleClicked = False      # Reset flag
        
        # Creating a rectangular region
        elif self.toggleSquare.GetValue():
            # Making the second corner of rectangle
            if self.polyVerts and pt.Dist(self.polyVerts[0]) > self.tolerance:
                pt1 = Point(self.polyVerts[0].x, pt.y)
                pt3 = Point(pt.x, self.polyVerts[0].y)
                self.polyVerts.append(pt1)
                self.polyVerts.append(pt)
                self.polyVerts.append(pt3)
                # Create a square between previous click and new click
                self.AddToUndo()
                self.CreateRegion()
            # Making the first corner of rectangle
            else:
                # Save point as first corner of square
                self.polyVerts.append(pt)

        # Creating a polygonal region
        elif self.togglePoly.GetValue():
            # Closing the polygon to create a region
            if self.polyVerts and len(self.polyVerts) > 2 and \
                    pt == self.polyVerts[0]:
                self.AddToUndo()
                self.CreateRegion()
            # New point distinct from others
            elif not pt in self.polyVerts:
                self.polyVerts.append(pt)
                # Plot line between last two points
                if len(self.polyVerts) > 1:
                    x1pix, y1pix = self.Map2Pix(self.polyVerts[-2])
                    x2pix, y2pix = self.Map2Pix(pt)
                    dc = wx.WindowDC(self.canvas)
                    dc.DrawLine(x1pix, y1pix, x2pix, y2pix)

        # Dimensioning region edge
        elif self.toggleDim.GetValue():
            # First point on region to be clicked
            if not self.polyVerts and iReg != -1 and iPt != -1:
                # Store region and point indeces
                self.polyVerts = (iReg, iPt)
            # Second unique point to be clicked
            elif iReg != -1 and iPt != -1 and (iReg, iPt) != self.polyVerts:
                # Request dimension
                currDist = self.regions[iReg].verts[iPt].Dist(self.regions[\
                    self.polyVerts[0]].verts[self.polyVerts[1]])
                dimDlg = wx.TextEntryDialog(self, \
                    "Current Length: %.3f" % currDist, caption='Dimension')
                if dimDlg.ShowModal() == wx.ID_OK:
                    # Check for valid dimension (allow negative values)
                    try:
                        dim = float(dimDlg.GetValue())
                    except ValueError:
                        dimDlg.Destroy()
                        return
                    dimDlg.Destroy()

                    # Move second point along same line to specified distance
                    pt0 = self.regions[self.polyVerts[0]].verts[self.polyVerts[1]]
                    signx = 1.0
                    signy = 1.0
                    # Vertical line case
                    if pt0.x == pt.x:
                        if pt0.y > pt.y:
                            signy = -1.0
                        dx = 0.0
                        dy = signy * (dim - pt.Dist(pt0))
                    # Horizontal and normal line cases
                    else:
                        if pt0.x > pt.x:
                            signx = -1.0
                        if pt0.y > pt.y:
                            signy = -1.0
                        slope = (pt.y - pt0.y) / (pt.x - pt0.x)
                        dx = signx * (dim - pt.Dist(pt0)) / \
                            math.sqrt(1 + slope ** 2)
                        dy = slope * dx
                    self.AddToUndo()
                    self.regions[iReg].verts[iPt] += Point(dx, dy)
                    self.polyVerts = []
                    self.RecalcAdjacency(iReg)
                    self.RedrawCanvas()
        
        # Dragging region(s) or vertices
        elif self.selectedRegions and \
                pt.Dist(self.leftClickPt) > self.tolerance:
            self.leftClickPt, iReg, iPt, iEd, snapped = \
                self.SnapRegions(self.leftClickPt)
            iRegInner = self.InsideRegions(self.leftClickPt)
            
            # Dragging point(s)
            if iReg in self.selectedRegions and iPt != -1:
                # Change point position and check adjacencies
                self.AddToUndo()
                self.regions[iReg].verts[iPt].Set(pt.x, pt.y)
                self.RecalcAdjacency(iReg)
                self.RedrawCanvas()
            
            # Dragging region(s)
            elif iReg in self.selectedRegions or \
                    iRegInner in self.selectedRegions:
                # Change region(s) position and check adjacencies
                self.AddToUndo()
                delta = pt - self.leftClickPt
                for iRegSel in self.selectedRegions:
                    for iPt in range(len(self.regions[iRegSel].verts)):
                        self.regions[iRegSel].verts[iPt] += delta
                for iRegSel in self.selectedRegions:
                    self.RecalcAdjacency(iRegSel)
                self.RedrawCanvas()
        
        # Panning the map view
        elif pt.Dist(self.leftClickPt) > self.tolerance:
            downClickPix = self.Map2Pix(self.leftClickPt)
            self.canvasOffset = Point(self.canvasScale.x * \
                (downClickPix[0] - ptPix[0]) + self.canvasOffset.x, \
                self.canvasScale.y * (downClickPix[1] - ptPix[1]) + \
                self.canvasOffset.y)
            self.RedrawCanvas()
        
        # Check if selecting or deselecting a region
        else:
            if iReg != -1:
                iRegInner = iReg
            else:
                iRegInner = self.InsideRegions(pt)
            
            # Do something about that region selection
            if iRegInner != -1:
                # Selecting single region
                if not event.CmdDown():
                    self.selectedRegions = []
                    self.selectedRegions.append(iRegInner)
                
                # Deselecting a region
                elif iRegInner in self.selectedRegions:
                    self.selectedRegions.remove(iRegInner)
                
                # Adding a region to the selection
                else:
                    self.selectedRegions.append(iRegInner)
            
            # Clear all region selections
            else:
                self.selectedRegions = []
            self.RedrawCanvas()
    
    def OnMouseLeftDClick(self, event):
        """Perform action based on current mode of operation."""
        
        # Set double-click flag so that next mouse-up is ignored
        self.justDoubleClicked = True
        
        # Creating a polygonal region
        if self.togglePoly.GetValue() and self.polyVerts and \
                len(self.polyVerts) > 2:
            self.AddToUndo()
            self.CreateRegion()
        
        # Editing a region
        if self.selectedRegions and not self.toggleSquare.GetValue() and \
                not self.togglePoly.GetValue() and \
                not self.toggleDim.GetValue():
            # Unset double-click flag since event does not propagate here
            self.justDoubleClicked = False
            
            # Edit the latest selected region
            iReg = self.selectedRegions.pop()
            self.selectedRegions = []
            self.selectedRegions.append(iReg)
            self.EditRegion(iReg)
    
    def OnMouseRightDown(self, event):
        """Save the right click point so it can be used later."""
        self.rightClickPt, iReg, iPt, iEd = \
            self.SnapPoint(self.Pix2Map(event.GetPosition()))

    def OnMouseRightUp(self, event):
        # Check if in region creation or dimensioning mode
        if self.toggleSquare.GetValue() or self.togglePoly.GetValue() or \
                self.toggleDim.GetValue():
            self.ResetMapToggles()
        # TODO: else: open some kind of right-click menu at right-click point

    def OnMouseWheel(self, event):
        """Zoom on the map canvas."""
        ptPix = event.GetPosition()
        rot = event.GetWheelRotation()          # Usually +/- multiple of 120
        scaler = 0.75 ** (rot / 120)            # Zoom in to 75%
        # Keep mouse on the same point after zooming
        # pt = ptPix * scale + offset
        # pt = ptPix * scaleNew + offsetNew
        self.canvasOffset = Point(float(ptPix[0]) * self.canvasScale.x * \
            (1 - scaler) + self.canvasOffset.x, float(ptPix[1]) * \
            self.canvasScale.y * (1 - scaler) + self.canvasOffset.y)
        self.canvasScale = self.canvasScale * scaler
        self.RedrawCanvas()
    
    def OnKeyDown(self, event):
        keycode = event.GetKeyCode()
        
        # Backspace/Delete - Deletes selected regions
        if (keycode == wx.WXK_BACK or keycode == wx.WXK_DELETE) and \
                self.selectedRegions and not self.togglePoly.GetValue() and \
                not self.toggleSquare.GetValue():
            self.AddToUndo()
            self.selectedRegions.sort()
            while self.selectedRegions:
                self.DeleteRegion(self.selectedRegions.pop())
        
        # Backspace/Delete - Removes last set point during region creation
        elif (keycode == wx.WXK_BACK or keycode == wx.WXK_DELETE) and \
                self.polyVerts:
            if self.toggleSquare.GetValue() or self.togglePoly.GetValue():
                self.polyVerts.pop()
                self.RedrawCanvas()
            elif self.toggleDim.GetValue():
                self.polyVerts = []
        
        # Escape - Stops region/dimension creation
        elif keycode == wx.WXK_ESCAPE and (self.toggleSquare.GetValue() or \
                self.togglePoly.GetValue() or self.toggleDim.GetValue()):
            self.ResetMapToggles()
        
        # Ctrl+n - New
        elif event.CmdDown() and keycode == 78:
            self.OnMenuNew(None)
        
        # Ctrl+o - Open
        elif event.CmdDown() and keycode == 79:
            self.OnMenuOpen(None)
        
        # Ctrl+s - Save
        elif event.CmdDown() and keycode == 83:
            self.OnMenuSave(None)
        
        # Ctrl+q - Quit
        elif event.CmdDown() and keycode == 81:
            self.OnMenuExit(None)
        
        # Ctrl+z - Undo
        elif event.CmdDown() and keycode == 90:
            self.OnMenuUndo(None)
        
        # Ctrl+y - Redo
        elif event.CmdDown() and keycode == 89:
            self.OnMenuRedo(None)
        
        # Ctrl+a - Select All
        elif event.CmdDown() and keycode == 65:
            self.selectedRegions = range(len(self.regions))
            self.RedrawCanvas()
        
        # Pass event on so other key combinations still work
        else:
            event.Skip()
    
    def OnEnterWindow(self, event):
        """Set the focus to the canvas to enable zooming."""
        self.canvas.SetFocus()
        self.RedrawCanvas()
    
    def OnLeaveWindow(self, event):
        """Unset the focus from the canvas to disable zooming."""
        self.SetFocus()
    
    def OnCanvasPaint(self, event):
        """Redraw the contents of the canvas panel."""
        # Set up to draw
        dc = wx.PaintDC(self.canvas)
        
        # Redraw
        self.RedrawCanvas(dc)
        event.Skip()
    
    def RedrawCanvas(self, dc=None):
        """Redraw the contents of the canvas panel.
        Callable from outside or inside EVT_PAINT handler.
        
        dc - Device context object for drawing to canvas.
        """
        # Clear canvas
        self.canvas.ClearBackground()
        
        # Create device context if not created
        if not dc:
            dc = wx.WindowDC(self.canvas)
        dc = wx.GCDC(dc)
        self.canvas.PrepareDC(dc)
        dc.BeginDrawing()
        
        # Draw grid background
        self.DrawGrid(dc)
        
        # Redraw all regions
        for region in self.regions:
            self.DrawRegion(region, dc=dc)
        
        # Redraw all transition face indicators
        # Lower triangular matrix only
        for iReg in range(1, len(self.adjacent)):
            self.DrawAdjacencies(iReg, dc=dc)
        
        # Redraw all markers
        self.DrawMarkers(self.markerPoses, dc=dc)
        
        # Redraw selection handles
        for iReg in self.selectedRegions:
            self.DrawSelectionHandle(iReg, dc=dc)
        
        # Redraw partial region
        if self.toggleSquare.GetValue() or self.togglePoly.GetValue():
            for iVert in range(len(self.polyVerts) - 1):
                ptPix1 = self.Map2Pix(self.polyVerts[iVert])
                ptPix2 = self.Map2Pix(self.polyVerts[iVert + 1])
                dc.DrawLine(ptPix1[0], ptPix1[1], ptPix2[0], ptPix2[1])
        
        dc.EndDrawing()
    
    def RedrawVicon(self):
        """Redraw the contents of the canvas panel quickly, only worrying about
        updating the marker positions and currently being created regions.
        """
        # TODO: Save and use image of map to increase speed
        self.RedrawCanvas()
    
    def DrawGrid(self, dc=None):
        """Draw the axes and grid on the map canvas.

        dc - Device context used for drawing on the canvas panel.
        """
        # Create device context if not created
        isNewDC = False
        if not dc:
            isNewDC = True
            windc = wx.WindowDC(self.canvas)
            dc = wx.GCDC(windc)
            self.canvas.PrepareDC(dc)
            dc.BeginDrawing()

        # Draw axes
        xOff = self.canvasOffset.x
        yOff = self.canvasOffset.y
        xPixOff = int(-xOff / self.canvasScale.x)
        yPixOff = int(-yOff / self.canvasScale.y)
        colLim, rowLim = self.canvas.GetSize()
        dc.DrawLine(0, yPixOff, colLim, yPixOff)
        dc.DrawLine(xPixOff, 0, xPixOff, rowLim)
        
        # TODO: Draw grid/ticks
        
        if isNewDC:
            dc.EndDrawing()

    def DrawMarkers(self, poses, dc=None):
        """Draw markers at specified global positions.

        poses - List of tuples containing positions of markers in meters
                [(x, y), ...]
        dc - Device context used for drawing on the canvas panel.
        """
        # Create device context if not created
        isNewDC = False
        if not dc:
            isNewDC = True
            windc = wx.WindowDC(self.canvas)
            dc = wx.GCDC(windc)
            self.canvas.PrepareDC(dc)
            dc.BeginDrawing()
        
        # Set up brush
        #dc.SetBrush(wx.Brush(wx.Colour(255, 255, 255, 128), wx.SOLID))
        
        # Draw each marker
        for pose in poses:
            posePix = self.Map2Pix(pose)
            dc.DrawCircle(posePix[0], posePix[1], 4)
        
        if isNewDC:
            dc.EndDrawing()
    
    def DrawSelectionHandle(self, iReg, dc=None):
        """Draw markers indicating region(s) that have been selected by mouse.
        
        iReg - Index of region selected
        dc - Device context used for drawing on the canvas panel
        """
        # Create device context if not created
        isNewDC = False
        if not dc:
            isNewDC = True
            windc = wx.WindowDC(self.canvas)
            dc = wx.GCDC(windc)
            self.canvas.PrepareDC(dc)
            dc.BeginDrawing()
        
        for pt in self.regions[iReg].verts:
            ptPix = self.Map2Pix(pt)
            dc.DrawCircle(ptPix[0], ptPix[1], 5)
        
        if isNewDC:
            dc.EndDrawing()

    def DrawRegion(self, region, dc=None):
        """Draw a single region.

        region - Instance of Region class, contains information about the region.
        dc - Device context used for drawing on the canvas panel.
        """
        # Create device context if not created
        isNewDC = False
        if not dc:
            isNewDC = True
            windc = wx.WindowDC(self.canvas)
            dc = wx.GCDC(windc)
            self.canvas.PrepareDC(dc)
            dc.BeginDrawing()
        
        # Set brush to region color
        isBoundary = region.name.lower() == "boundary"
        if isBoundary:
            dc.SetBrush(wx.Brush(region.color, wx.TRANSPARENT))
            dc.SetPen(wx.Pen(wx.BLACK, 3, wx.SOLID))
        elif region.isObstacle:
            obstColor = wx.Colour(region.color.Red() / 10, \
                region.color.Green() / 10, region.color.Blue() / 10, 128)
            dc.SetBrush(wx.Brush(obstColor, wx.SOLID))
            dc.SetPen(wx.Pen(region.color, 1, wx.SOLID))
        else:
            innerColor = wx.Colour(region.color.Red(), region.color.Green(), \
                region.color.Blue(), 128)
            dc.SetBrush(wx.Brush(innerColor, wx.SOLID))
            dc.SetPen(wx.Pen(region.color, 1, wx.SOLID))
        dc.SetTextForeground(wx.BLACK)
        dc.SetBackgroundMode(wx.TRANSPARENT)
        dc.SetFont(wx.Font(12, wx.FONTFAMILY_SWISS, wx.NORMAL, wx.BOLD, False))
        
        # Set up label
        if region.isObstacle:
            labelText = "(%s)" % region.name
        else:
            labelText = region.name
        labelWidth, labelHeight = dc.GetTextExtent(labelText)
        
        # Draw region
        vertsPix = []
        xLabelPix = 0
        yLabelPix = 0
        for vert in region.verts:
            vertPix = self.Map2Pix(vert)
            vertsPix.append(vertPix)
            if not isBoundary:          # Put label in center
                xLabelPix += vertPix[0]
                yLabelPix += vertPix[1]
            else:                       # Put label in lower right corner
                xLabelPix = max(xLabelPix, vertPix[0])
                yLabelPix = max(yLabelPix, vertPix[1])
        dc.DrawPolygon(vertsPix)
        if isBoundary:
            xLabelPix = xLabelPix - labelWidth
        else:
            xLabelPix = xLabelPix / len(region.verts) - labelWidth / 2
            yLabelPix = yLabelPix / len(region.verts) - labelHeight / 2
        
        # Draw label
        if not isBoundary:
            dc.SetBrush(wx.Brush(region.color, wx.SOLID))
            dc.DrawRoundedRectangle(xLabelPix - 5, yLabelPix - 3, \
                labelWidth + 10, labelHeight + 6, 3)
        dc.DrawText(labelText, xLabelPix, yLabelPix)
        
        if isNewDC:
            dc.EndDrawing()
    
    def DrawAdjacencies(self, iReg, dc=None):
        """Draw lines to show adjacent region faces for one region.
        Uses self.regions and self.adjacent.
        
        iReg - Int, index of region of interest in self.regions.
        dc - Device context used for drawing on the canvas panel.
        """
        # Create device context if not created
        if not dc:
            windc = wx.WindowDC(self.canvas)
            dc = wx.GCDC(windc)
            self.canvas.PrepareDC(dc)
            dc.BeginDrawing()
        dc.SetPen(wx.Pen(wx.Colour(255, 0, 0), 3, wx.SHORT_DASH))
        
        # Iterate adjacency matrix looking for shared faces for one region
        # Only need to iterate through lower triangle (not counting diagonal) 
        # since the matrix is "symmetric" and diagonal is just region to itself
        for jReg in range(iReg):
            for iREdge1, iREdge2 in self.adjacent[iReg][jReg]:
                # Not last edge in region
                pt1 = self.regions[iReg].verts[iREdge1]
                if iREdge1 < len(self.regions[iReg].verts) - 1:
                    pt2 = self.regions[iReg].verts[iREdge1 + 1]
                # Last edge in region
                else:
                    pt2 = self.regions[iReg].verts[0]
                pt1Pix = self.Map2Pix(pt1)
                pt2Pix = self.Map2Pix(pt2)
                dc.DrawLine(pt1Pix[0], pt1Pix[1], pt2Pix[0], pt2Pix[1])
    
    def ResetMapToggles(self, toggleStay=None):
        """Clear all the other map-feature toggle buttons.
        Also resets region creation.

        toggleStay - Toggle button object to retain state.
        """
        # Reset region creation and clear temporary lines
        self.polyVerts = []
        self.RedrawCanvas()

        # Turn off all toggles and revert specified one
        if toggleStay:
            state = toggleStay.GetValue()
        self.toggleSquare.SetValue(False)
        self.togglePoly.SetValue(False)
        self.toggleDim.SetValue(False)
        if toggleStay:
            toggleStay.SetValue(state)

    def CreateRegion(self):
        """Instantiate and create a region, perform cleanup actions.
        Use polyVerts and polyAdjEdges to make the region and find transitions.
        """
        # Create region
        rName = 'r' + str(len(self.regions))
        region = Region(self.polyVerts, rName)
        self.regions.append(region)
        idxNewReg = len(self.regions) - 1
        # Add row and column to list of lists of lists representing adjacency
        self.adjacent.append([[] for col in xrange(len(self.adjacent))])
        for row in self.adjacent:
            row.append([])
        
        self.RecalcAdjacency(idxNewReg)
        
        # Cleanup and draw
        self.polyVerts = []
        self.polyAdjEdges = []
        self.DrawRegion(region)
        self.DrawAdjacencies(idxNewReg)
    
    def DeleteRegion(self, iReg):
        """Removes region from regions list and adjacency list.
        
        iReg - Index of region to remove
        """
        # Remove region from tracking lists
        self.regions.pop(iReg)
        self.adjacent.pop(iReg)
        for jReg in range(len(self.regions)):
            self.adjacent[jReg].pop(iReg)
        
        # Redraw regions
        self.RedrawCanvas()

    def AddPointToRegion(self, pt, iReg, iEdge):
        """Add a vertex to the region.
        
        pt - Point object, location of new vertex in map coordinates
        iRegion - Int, index of region to modify
        iEdge - Int, index of the edge to replace with edges to and from pt
        """
        # Add point to other region
        self.regions[iReg].verts.insert(iEdge + 1, copy.copy(pt))
        # Update all transition edges
        # Loop through all regions
        for jReg in range(len(self.adjacent[iReg])):
            # All transitioning faces from region to others
            for kPair in range(len(self.adjacent[iReg][jReg])):
                thisRegFace, otherRegFace = self.adjacent[iReg][jReg][kPair]
                # Transition face has index greater than affected edge
                if thisRegFace > iEdge:
                    self.adjacent[iReg][jReg][kPair] = \
                        (thisRegFace + 1, otherRegFace)
                # Transition face is the affected edge
                elif thisRegFace == iEdge:
                    self.adjacent[iReg][jReg].\
                        append((thisRegFace + 1, otherRegFace))
            # All transitioning faces from other regions to this one
            for kPair in range(len(self.adjacent[jReg][iReg])):
                otherRegFace, thisRegFace = self.adjacent[jReg][iReg][kPair]
                # Transition face has index greater than affected edge
                if thisRegFace > iEdge:
                    self.adjacent[jReg][iReg][kPair] = \
                        (otherRegFace, thisRegFace + 1)
                # Transition face is the affected edge
                elif thisRegFace == iEdge:
                    self.adjacent[jReg][iReg].\
                        append((otherRegFace, thisRegFace + 1))
    
    def EditRegion(self, iReg):
        """Show the edit region dialog.
        Allow user to change name, color, and obstacleness of a region.
        
        iReg - Index of region to edit
        """
        # Create dialog
        regEdDia = RegionEditDialog(self, wx.ID_ANY, "Edit Region Information")
        
        # Set appropriate control values
        reg = self.regions[iReg]
        regEdDia.textName.SetValue(reg.name)
        regEdDia.colorPicker.SetColour(reg.color)
        regEdDia.chkbxObst.SetValue(reg.isObstacle)
        
        # Wait for user to close the dialog
        done = False
        while not done:
            answer = regEdDia.ShowModal()
            # User canceled
            if answer == wx.ID_CANCEL:
                regEdDia.Destroy()
                done = True
            # Same name or unique new name
            elif regEdDia.textName.GetValue() == reg.name or \
                    regEdDia.textName.GetValue() not in \
                    [r.name for r in self.regions]:
                self.AddToUndo()
                reg.name = regEdDia.textName.GetValue()
                reg.color = regEdDia.colorPicker.GetColour()
                reg.isObstacle = regEdDia.chkbxObst.GetValue()
                regEdDia.Destroy()
                done = True
            # Non-unique name - needs to re-edit
            else:
                wx.MessageBox("Region with name \"%s\" already exists." % \
                    (regEdDia.textName.GetValue()), "Error", \
                    style = wx.OK | wx.ICON_ERROR)
        
        # Redraw the regions to ensure correct name/color
        self.RedrawCanvas()
    
    def RecalcAdjacency(self, iReg, iRegStart=0):
        """Recalculate the adjacent walls between the specified region and
        other regions. If walls or points are "close enough" to being colinear
        or colocated, they will be moved so that they overlap. The saved
        adjacency matrix will be updated accordingly.
        
        Can specify which region to start checking with so that the input
        region will not check against all regions. This is useful if entire map
        needs to be rechecked, it can be done so with:
        
            for iReg, reg in enumerate(self.regions):
                self.RecalcAdjacency(iReg, iRegStart=iReg)
        
        This will avoid redundant checking of regions. Note that the function
        will avoid checking against itself, so there is no reason to avoid
        calling it on itself. It will also not check against the boundary
        region.
        
        iReg - Index of region of interest
        iRegStart - Specifies to check reg against self.regions[iRegStart:]
        """
        # Reset adjacency related to this region
        for iOthReg in range(len(self.regions)):
            self.adjacent[iReg][iOthReg] = []
            self.adjacent[iOthReg][iReg] = []
        
        # Pull region for easy access
        reg = self.regions[iReg]
        
        # Don't check for anything else if boundary
        if reg.name.lower() == "boundary":
            return
        
        # Keeps track of the colocation of vertices of this region with points
        # of other regions
        # List of lists of tuples
        # Outer list - len(vertColloc) == len(reg.verts)
        # Inner list - Contains collocation information for each region vertex
        # Tuple - Contains collocation information from vertex on this region
        #         to vertex on another region in the format:
        #         (iReg, iPt)
        vertsColloc = [[] for iPt in xrange(len(reg.verts))]
        
        # Check all other regions against this region
        for iOthReg in range(len(self.regions[iRegStart:])):
            # No need to check against self
            if iOthReg == iReg or \
                    self.regions[iOthReg].name.lower() == "boundary":
                continue
            
            for iOthPt, othPt in enumerate(self.regions[iOthReg].verts):
                pt, iPt, iEd, snapped = self.Snap1Region(reg, othPt)
                # Other region vertex snapped to wall of new region
                if iEd != -1:
                    # Add point to new region and update old transitions
                    self.AddPointToRegion(pt, iReg, iEd)
                    vertsColloc.append([])
                    # Don't bother tracking point connectivity here
                    # Recheck it in next loop so we can look at all regions
        
        # Check this region against others and create new vertices as necessary
        for iPt, pt in enumerate(reg.verts):
            snapResults = self.SnapRegions(pt, checkAll=True)
            # Process the "nearness" information
            for othPt, iOthReg, iOthPt, iOthEd in snapResults:
                # Ignore same region
                if iOthReg == iReg:
                    continue
                
                # Change region point location
                pt.Set(othPt.x, othPt.y)
                
                # Snapped to a point in the other region
                if iOthPt != -1:
                    vertsColloc[iPt].append((iOthReg, iOthPt))
                # Snapped to an edge of the other region
                elif iOthEd != -1:
                    self.AddPointToRegion(pt, iOthReg, iOthEd)
                    vertsColloc[iPt].append((iOthReg, iOthEd + 1))
        
        # Now look for adjacent edges and update transition matrix accordingly
        for iPt in range(len(reg.verts)):       # Start point of edge
            jPt = (iPt + 1) % len(reg.verts)    # End point of edge
            for iOthReg, iOthPt in vertsColloc[iPt]:
                jOthPt1 = (iOthPt - 1) % len(self.regions[iOthReg].verts)
                jOthPt2 = (iOthPt + 1) % len(self.regions[iOthReg].verts)
                # Check edge on other region prior to point
                if (iOthReg, jOthPt1) in vertsColloc[jPt]:
                    # Indicate transition from this region to other region
                    # from current this region side to other region side
                    # and reverse transition as well
                    self.adjacent[iReg][iOthReg].append((iPt, jOthPt1))
                    self.adjacent[iOthReg][iReg].append((jOthPt1, iPt))
                # Check edge on other region after point
                elif (iOthReg, jOthPt2) in vertsColloc[jPt]:
                    self.adjacent[iReg][iOthReg].append((iPt, iOthPt))
                    self.adjacent[iOthReg][iReg].append((iOthPt, iPt))
    
    def IndexOfRegionWithName(self, name):
        for i, region in enumerate(self.regions):
            if region.name.lower() == name.lower():
                return i
        print 'WARNING: Region "' + name + '" not found.'
        return -1
    
    def ExistBoundary(self):
        """Check if a boundary region has been defined."""
        found = False
        iReg = 0
        while not found and iReg < len(self.regions):
            found = self.regions[iReg].name.lower() == "boundary"
            iReg += 1
        
        return found
    
    def Autoboundary(self):
        """Automatically create region representing the boundary of the map."""
        if self.regions:
            minx, maxx, miny, maxy = self.GetMapBoundaries()
            # Create region
            points = [Point(minx, maxy), Point(maxx, maxy), \
                Point(maxx, miny), Point(minx, miny)]
            self.regions.append(Region(points, 'boundary'))
        else:
            print "No regions defined, so no boundary created."
    
    def GetMapBoundaries(self):
        """Find the minimum and maximum coordinates of all regions on map.
        
        returns None if no regions defined
        returns (minX, maxX, minY, maxY) otherwise
        """
        # Check that there are regions first
        if self.regions:
            # Find extrema of map
            minx = float('inf')
            maxx = float('-inf')
            miny = float('inf')
            maxy = float('-inf')
            for reg in self.regions:
                for pt in reg.verts:
                    minx = min(minx, pt.x)
                    maxx = max(maxx, pt.x)
                    miny = min(miny, pt.y)
                    maxy = max(maxy, pt.y)
            
            return minx, maxx, miny, maxy
        else:
            return None

    def AddToUndo(self):
        """Add current state to the undo queue."""
        # Note that this is only called when doing a new action,
        # not when redoing since this clears the redo buffer
        action = Action(self.regions, self.adjacent)
        print action.stateRegions, action.stateAdjacent
        self.undoActions.append(action)
        while len(self.undoActions) > self.unredoBufLen:
            self.undoActions.popleft()
        self.redoActions.clear()
        # TODO: enable self.menuUndo

    def SnapPoint(self, pt):
        """Snap the point to any nearby Vicon or region point.

        pt - Point object, map coordinates of point
        returns - (snappedPt, idxRegion, idxRPoint, idxREdge)
            snappedPt - Point object, point after snapping
            idxRegion - int, index of region if snapped to region point/edge
                        if not snapped to region it will be -1
            idxRPoint - int, index of point in region.verts if snapped to point
                        if not snapped to point it will be -1
            idxREdge - int, index of side in region if snapped to edge
                       edge j is defined by region.verts[j:j+1]
                       if not snapped to edge it will be -1
        """
        # TODO: Make menubar checkbox to disable/enable snapto
        # Check through all region points and edges first
        # (since Vicon points may be moving around)
        snapped = False
        pt, idxRegion, idxRPoint, idxREdge, snapped = \
            self.SnapRegions(pt, snapped=snapped)

        # Check points in current region creation
        # Only snap to vertices
        # Don't count this for iRegion or iRPoint
        pt, idxPolyPoint, snapped = self.SnapPoly(pt, snapped=snapped)

        # Check all Vicon points
        pt, idxMarker, snapped = self.SnapVicon(pt, snapped)

        # Only return region indices, since they are usually all that matter
        return pt, idxRegion, idxRPoint, idxREdge

    def SnapRegions(self, pt, checkAll=False, snapped=False):
        """Snap the point to any sufficiently "nearby" region vertex or wall.

        pt - Point object, map coordinates of point
        checkAll - Boolean, true if this function should check the point
                   against all regions, even if it has already snapped to one
        snapped - Boolean, true if point has snapped already, false if not
                  If point is already snapped, this function will just return
        returns -
            If checkAll is true, then the return will be a list containing
            tuples in the format (snappedPt, idxRegion, idxRPoint, idxREdge),
            where each entry is as described below. If there is no snapping
            then the list will be empty.
            If checkAll is false, then a single tuple will be returned:
            (snappedPt, idxRegion, idxRPoint, idxREdge, snapped)
                snappedPt - Point object, point after snapping
                idxRegion - int, index of region if snapped to region point/edge
                            if not snapped to region it will be -1
                idxRPoint - int, index of point in region.verts if snapped to point
                            if not snapped to point it will be -1
                idxREdge - int, index of side in region if snapped to edge
                           edge j is defined by region.verts[j:j+1]
                           if not snapped to edge it will be -1
                snapped - Boolean, true if point has been snapped, false if not
                          Note that if input snapped is true, output will be true
                          even if the point did not snap to a region point or edge
        """
        # Initialize output
        if not checkAll:
            idxRegion = -1
            idxRPoint = -1
            idxREdge = -1
        else:
            output = []
        
        # Check through regions
        i = len(self.regions) - 1   # Region decrementer
        while (checkAll or not snapped) and i >= 0:
            pt, idxRPoint, idxREdge, snapped = \
                self.Snap1Region(self.regions[i], pt, \
                snapped=(not checkAll and snapped))
            if idxRPoint != -1 or idxREdge != -1:
                idxRegion = i
                if checkAll:
                    output.append((pt, idxRegion, idxRPoint, idxREdge))
            i -= 1
        
        if not checkAll:
            return pt, idxRegion, idxRPoint, idxREdge, snapped
        else:
            return output
    
    def Snap1Region(self, region, pt, snapped=False):
        """Snap the point to any sufficiently "nearby" region vertex or wall
        in the specified region.
        
        region - Region object, region of interest
        pt - Point object, map coordinates of point
        snapped - Boolean, true is point has snapped already, false if not
                  If point is already snapped, this function will just return
        returns - (snappedPt, idxRPoint, idxREdge, snapped)
            snappedPt - Point object, point after snapping
            idxRPoint - int, index of point in region.verts if snapped to point
                        if not snapped to point it will be -1
            idxREdge - int, index of side in region if snapped to edge
                       edge j is defined by region.verts[j:j+1]
                       if not snapped to edge it will be -1
            snapped - Boolean, true if point has been snapped, false if not
                      Note that if input snapped is true, output will be true
                      even if the point did not snap to a region point or edge
        """
        idxRPoint = -1
        idxREdge = -1
        # Check first point
        chkPt = region.verts[0]
        if (not snapped) and pt.Dist(chkPt) < self.tolerance:
            pt = chkPt
            snapped = True
            idxRPoint = 0
        j = 1   # Region point incrementer
        while (not snapped) and j < len(region.verts):
            # Check next point
            chkPt = region.verts[j]
            if pt.Dist(chkPt) < self.tolerance:
                pt = chkPt
                snapped = True
                idxRPoint = j
            # Check edge between previous and just-checked point
            else:
                p0 = region.verts[j - 1]
                p1 = chkPt
                chkPt = self.ProjPtOnLine(pt, p0, p1)
                # Check that projected point is on finite line and close
                if pt.Dist(chkPt) < self.tolerance and \
                        chkPt.x <= max(p0.x, p1.x) and \
                        chkPt.x >= min(p0.x, p1.x) and \
                        chkPt.y <= max(p0.y, p1.y) and \
                        chkPt.y >= min(p0.y, p1.y):
                    pt = chkPt
                    snapped = True
                    idxREdge = j - 1
            j += 1
        # Check last edge
        if not snapped:
            p0 = region.verts[j - 1]
            p1 = region.verts[0]
            chkPt = self.ProjPtOnLine(pt, p0, p1)
            if pt.Dist(chkPt) < self.tolerance and \
                    chkPt.x <= max(p0.x, p1.x) and \
                    chkPt.x >= min(p0.x, p1.x) and \
                    chkPt.y <= max(p0.y, p1.y) and \
                    chkPt.y >= min(p0.y, p1.y):
                pt = chkPt
                snapped = True
                idxREdge = j - 1
        
        return copy.copy(pt), idxRPoint, idxREdge, snapped
    
    def SnapPoly(self, pt, snapped=False):
        """Snap the point to any vertex in the currently being created region
        if it is sufficiently "nearby".

        pt - Point object, map coordinates of point
        snapped - Boolean, true is point has snapped already, false if not
                  If point is already snapped, this function will just return
        returns - (snappedPt, idxPoint, snapped)
            snappedPt - Point object, point after snapping
            idxPoint - int, index of point in self.polyVerts if snapped to it
                       if not snapped to point it will be -1
            snapped - Boolean, true if point has been snapped, false if not
                      Note that if input snapped is true, output will be true
                      even if the point did not snap to a polygon point
        """
        idxPoint = -1
        i = 0       # Misc point incrementer
        while (not snapped) and i < len(self.polyVerts):
            chkPt = self.polyVerts[i]
            if pt.Dist(chkPt) < self.tolerance:
                pt = chkPt
                idxPoint = i
                snapped = True
            i += 1

        return copy.copy(pt), idxPoint, snapped

    def SnapVicon(self, pt, snapped):
        """Snap the point to any saved Vicon marker position if it is
        sufficiently "nearby".

        pt - Point object, map coordinates of point
        snapped - Boolean, true is point has snapped already, false if not
                  If point is already snapped, this function will just return
        returns - (snappedPt, idxMarker, snapped)
            snappedPt - Point object, point after snapping
            idxMarker - int, index of point in self.markerPoses if snapped
                        if not snapped to point it will be -1
            snapped - Boolean, true if point has been snapped, false if not
                      Note that if input snapped is true, output will be true
                      even if the point did not snap to a Vicon point
        """
        idxMarker = -1
        i = 0       # Vicon point incrementer
        while (not snapped) and i < len(self.markerPoses):
            chkPt = self.markerPoses[i]
            if pt.Dist(chkPt) < self.tolerance:
                pt = chkPt
                idxMarker = i
                snapped = True
            i += 1

        return copy.copy(pt), idxMarker, snapped
    
    def InsideRegions(self, pt):
        """Find region containing point. Looks through regions on top first
        (those that were created later). Does not return for boundary region.
        
        pt - Point, point of interest
        returns - int, index of containing region, or -1 if none
        """
        iReg = -1
        i = len(self.regions) - 1
        while iReg == -1 and i >= 0:
            if self.regions[i].name.lower() != "boundary" and \
                    self.regions[i].PtInRegion(pt):
                iReg = i
            i -= 1
        
        return iReg
    
    def Map2Pix(self, pose):
        """Convert from map coordinates to pixel coordinates.

        pose - Point, map coordinates of point
        returns - Tuple, pixel coordinates in canvas panel (col, row)
        """
        col = int((pose.x - self.canvasOffset.x) / self.canvasScale.x)
        row = int((pose.y - self.canvasOffset.y) / self.canvasScale.y)
        return (col, row)

    def Pix2Map(self, pixPose):
        """Convert from pixel coordinates to map coordinates.

        pixPose - Tuple, pixel coordinates in canvas panel (col, row)
        returns - Point, map coordinates of point
        """
        x = float(pixPose[0]) * self.canvasScale.x + self.canvasOffset.x
        y = float(pixPose[1]) * self.canvasScale.y + self.canvasOffset.y
        return Point(x, y)

    def ProjPtOnLine(self, pt, p0, p1):
        """Find the projection of a point on an infinite line.

        pt - Point object, point to be projected.
        p1 - Point object, one endpoint of line.
        p2 - Point object, other endpoint of line.
        returns - Point object, projected point on line.
        """
        s = p1 - p0                     # Vector to project on (p0 is origin)
        v = pt - p0                     # Vector to point to project
        u = (v.Dot(s) / s.Dot(s)) * s   # Projected vector
        return p0 + u                   # Map back to global coordinates
# end of class RegionEditor


class FeedbackDialog(wx.Dialog):
    def __init__(self, *args, **kwds):
        # begin wxGlade: FeedbackDialog.__init__
        kwds["style"] = wx.DEFAULT_DIALOG_STYLE
        wx.Dialog.__init__(self, *args, **kwds)
        self.buttonPrev = wx.Button(self, -1, "Previous")
        self.buttonPick = wx.Button(self, -1, "Select")
        self.buttonNext = wx.Button(self, -1, "Next")
        self.chkbxIterate = wx.CheckBox(self, -1, "Automatically iterate points when marker is in position")
        self.radioboxOption = wx.RadioBox(self, -1, "Feedback Method", choices=["Speech", "Beeping"], majorDimension=1, style=wx.RA_SPECIFY_ROWS)
        self.chkbxMute = wx.CheckBox(self, -1, "Mute")

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_BUTTON, self.OnButtonPrev, self.buttonPrev)
        self.Bind(wx.EVT_BUTTON, self.OnButtonPick, self.buttonPick)
        self.Bind(wx.EVT_BUTTON, self.OnButtonNext, self.buttonNext)
        # end wxGlade

        # Add close event handler to cleanup before closing
        self.Bind(wx.EVT_CLOSE, self.OnClose)

        # Save reference to RegionEditor GUI
        if len(args) > 0:
            self.parent = args[0]
        else:
            print "Warning: FeedbackDialog will not work without " + \
                "reference to RegionEditor GUI as first parameter."
            self.parent = None

        # Track current point
        self.chkbxIterate.SetValue(True)
        self.currReg = 0
        self.currPt = 0

        # Start audio feedback thread
        self.feedbackThread = AudioFeedbackThread(self, self.parent)
        self.feedbackThread.start()

    def __set_properties(self):
        # begin wxGlade: FeedbackDialog.__set_properties
        self.SetTitle("Marker Placement")
        self.buttonPrev.SetMinSize((50, 50))
        self.buttonPick.SetMinSize((50, 50))
        self.buttonNext.SetMinSize((50, 50))
        self.chkbxIterate.SetValue(1)
        self.radioboxOption.SetSelection(0)
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: FeedbackDialog.__do_layout
        sizerOuter = wx.BoxSizer(wx.VERTICAL)
        sizerOptions = wx.BoxSizer(wx.VERTICAL)
        sizerButtons = wx.BoxSizer(wx.HORIZONTAL)
        sizerButtons.Add(self.buttonPrev, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)
        sizerButtons.Add(self.buttonPick, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)
        sizerButtons.Add(self.buttonNext, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)
        sizerOuter.Add(sizerButtons, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        sizerOptions.Add(self.chkbxIterate, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)
        sizerOptions.Add(self.radioboxOption, 0, wx.ALL | wx.EXPAND, 5)
        sizerOptions.Add(self.chkbxMute, 0, wx.ALL, 5)
        sizerOuter.Add(sizerOptions, 1, wx.EXPAND, 0)
        self.SetSizer(sizerOuter)
        sizerOuter.Fit(self)
        self.Layout()
        # end wxGlade

    def OnClose(self, event):
        """Perform cleanup tasks and close the feedback dialog."""
        self.feedbackThread.stop()
        self.parent.toggleFeedback.SetValue(False)
        # TODO: Add wait/notify to make sure thread ended
        self.Destroy()

    def OnButtonPrev(self, event):  # wxGlade: FeedbackDialog.<event_handler>
        """Move back to previous point."""
        # Not first point in region
        if self.currPt > 0:
            self.currPt -= 1
        # First point in region
        else:
            # Not first region
            if self.currReg > 0:
                self.currReg -= 1
            # First region
            else:
                self.currReg = len(self.parent.regions) - 1
            self.currPt = len(self.parent.regions[self.currReg].verts) - 1

    def OnButtonPick(self, event):  # wxGlade: FeedbackDialog.<event_handler>
        #self.parent.Raise()
        print "Select not yet implemented."

    def OnButtonNext(self, event):  # wxGlade: FeedbackDialog.<event_handler>
        """Move on to next point."""
        # Not last point in region
        if self.currPt < len(self.parent.regions[self.currReg].verts) - 1:
            self.currPt += 1
        # Last point in region
        else:
            # Not last region
            if self.currReg < len(self.parent.regions) - 1:
                self.currReg += 1
            # Last region
            else:
                self.currReg = 0
            self.currPt = 0
# end of class FeedbackDialog

class RegionEditDialog(wx.Dialog):
    def __init__(self, *args, **kwds):
        # begin wxGlade: RegionEditDialog.__init__
        kwds["style"] = wx.DEFAULT_DIALOG_STYLE
        wx.Dialog.__init__(self, *args, **kwds)
        self.label_1 = wx.StaticText(self, -1, "Name: ")
        self.textName = wx.TextCtrl(self, -1, "")
        self.label_2 = wx.StaticText(self, -1, "Color: ")
        self.colorPicker = wx.ColourPickerCtrl(self, -1)
        self.chkbxObst = wx.CheckBox(self, -1, "Treat as obstacle")
        self.buttonOk = wx.Button(self, wx.ID_OK, "OK")
        self.buttonCancel = wx.Button(self, wx.ID_CANCEL, "Cancel")

        self.__set_properties()
        self.__do_layout()
        # end wxGlade

    def __set_properties(self):
        # begin wxGlade: RegionEditDialog.__set_properties
        self.SetTitle("Edit Region")
        self.colorPicker.SetMinSize((40, 40))
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: RegionEditDialog.__do_layout
        sizer_2 = wx.BoxSizer(wx.VERTICAL)
        sizer_5 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_4 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_3 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_3.Add(self.label_1, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)
        sizer_3.Add(self.textName, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)
        sizer_2.Add(sizer_3, 1, wx.EXPAND, 0)
        sizer_4.Add(self.label_2, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)
        sizer_4.Add(self.colorPicker, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)
        sizer_2.Add(sizer_4, 1, wx.EXPAND, 0)
        sizer_2.Add(self.chkbxObst, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_5.Add(self.buttonOk, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)
        sizer_5.Add(self.buttonCancel, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 8)
        sizer_2.Add(sizer_5, 1, wx.EXPAND, 0)
        self.SetSizer(sizer_2)
        sizer_2.Fit(self)
        self.Layout()
        # end wxGlade
# end of class RegionEditDialog

class CalibrationFrame(wx.Frame):
    def __init__(self, *args, **kwds):
        # begin wxGlade: CalibrationFrame.__init__
        kwds["style"] = wx.DEFAULT_FRAME_STYLE
        wx.Frame.__init__(self, *args, **kwds)
        
        # Menu Bar
        self.calibFrame_menubar = wx.MenuBar()
        self.filemenu = wx.Menu()
        self.menuReset = wx.MenuItem(self.filemenu, wx.NewId(), "Reset", "", wx.ITEM_NORMAL)
        self.filemenu.AppendItem(self.menuReset)
        self.menuSave = wx.MenuItem(self.filemenu, wx.NewId(), "Save", "", wx.ITEM_NORMAL)
        self.filemenu.AppendItem(self.menuSave)
        self.menuExit = wx.MenuItem(self.filemenu, wx.NewId(), "Exit", "", wx.ITEM_NORMAL)
        self.filemenu.AppendItem(self.menuExit)
        self.calibFrame_menubar.Append(self.filemenu, "File")
        self.editmenu = wx.Menu()
        self.menuUndo = wx.MenuItem(self.editmenu, wx.NewId(), "Undo", "", wx.ITEM_NORMAL)
        self.editmenu.AppendItem(self.menuUndo)
        self.menuRedo = wx.MenuItem(self.editmenu, wx.NewId(), "Redo", "", wx.ITEM_NORMAL)
        self.editmenu.AppendItem(self.menuRedo)
        self.editmenu.AppendSeparator()
        self.menuSelectAll = wx.MenuItem(self.editmenu, wx.NewId(), "Select All", "", wx.ITEM_NORMAL)
        self.editmenu.AppendItem(self.menuSelectAll)
        self.menuClearAll = wx.MenuItem(self.editmenu, wx.NewId(), "Clear All Points", "", wx.ITEM_NORMAL)
        self.editmenu.AppendItem(self.menuClearAll)
        self.calibFrame_menubar.Append(self.editmenu, "Edit")
        self.toolsmenu = wx.Menu()
        self.menuShowMarkers = wx.MenuItem(self.toolsmenu, wx.NewId(), "Show Markers", "", wx.ITEM_CHECK)
        self.toolsmenu.AppendItem(self.menuShowMarkers)
        self.menuClearMarkers = wx.MenuItem(self.toolsmenu, wx.NewId(), "Clear Markers", "", wx.ITEM_NORMAL)
        self.toolsmenu.AppendItem(self.menuClearMarkers)
        self.toolsmenu.AppendSeparator()
        self.menuLoadImage = wx.MenuItem(self.toolsmenu, wx.NewId(), "Load Image", "", wx.ITEM_NORMAL)
        self.toolsmenu.AppendItem(self.menuLoadImage)
        self.menuDimen = wx.MenuItem(self.toolsmenu, wx.NewId(), "Dimension Image", "", wx.ITEM_NORMAL)
        self.toolsmenu.AppendItem(self.menuDimen)
        self.menuClearImage = wx.MenuItem(self.toolsmenu, wx.NewId(), "Clear Image", "", wx.ITEM_NORMAL)
        self.toolsmenu.AppendItem(self.menuClearImage)
        self.calibFrame_menubar.Append(self.toolsmenu, "Tools")
        self.helpmenu = wx.Menu()
        self.menuHowTo = wx.MenuItem(self.helpmenu, wx.NewId(), "How To Use", "", wx.ITEM_NORMAL)
        self.helpmenu.AppendItem(self.menuHowTo)
        self.menuAbout = wx.MenuItem(self.helpmenu, wx.NewId(), "About", "", wx.ITEM_NORMAL)
        self.helpmenu.AppendItem(self.menuAbout)
        self.calibFrame_menubar.Append(self.helpmenu, "Help")
        self.SetMenuBar(self.calibFrame_menubar)
        # Menu Bar end
        self.sidebar = wx.Panel(self, -1)
        self.toggleVicon = wx.ToggleButton(self.sidebar, -1, "Markers")
        self.buttonImage = wx.Button(self.sidebar, -1, "Image")
        self.toggleAddPoint = wx.ToggleButton(self.sidebar, -1, "Point +")
        self.toggleDeletePoint = wx.ToggleButton(self.sidebar, -1, "Point -")
        self.textEnterPointX = wx.TextCtrl(self.sidebar, -1, "")
        self.textEnterPointY = wx.TextCtrl(self.sidebar, -1, "")
        self.buttonEnterPoint = wx.Button(self.sidebar, wx.ID_OK, "OK")
        self.toggleDimen = wx.ToggleButton(self.sidebar, -1, "Dimen.")
        self.buttonSave = wx.Button(self.sidebar, -1, "Save")
        self.chkbxShear = wx.CheckBox(self.sidebar, -1, "Lock aspect ratio")
        self.map = wx.Panel(self, -1, style=wx.SUNKEN_BORDER | wx.TAB_TRAVERSAL)
        self.ref = wx.Panel(self, -1, style=wx.SUNKEN_BORDER | wx.TAB_TRAVERSAL)

        self.__set_properties()
        self.__do_layout()

        self.Bind(wx.EVT_MENU, self.OnMenuReset, self.menuReset)
        self.Bind(wx.EVT_MENU, self.OnMenuSave, self.menuSave)
        self.Bind(wx.EVT_MENU, self.OnMenuExit, self.menuExit)
        self.Bind(wx.EVT_MENU, self.OnMenuUndo, self.menuUndo)
        self.Bind(wx.EVT_MENU, self.OnMenuRedo, self.menuRedo)
        self.Bind(wx.EVT_MENU, self.OnMenuSelectAll, self.menuSelectAll)
        self.Bind(wx.EVT_MENU, self.OnMenuClearAll, self.menuClearAll)
        self.Bind(wx.EVT_MENU, self.OnMenuShowMarkers, self.menuShowMarkers)
        self.Bind(wx.EVT_MENU, self.OnMenuClearMarkers, self.menuClearMarkers)
        self.Bind(wx.EVT_MENU, self.OnMenuLoadImage, self.menuLoadImage)
        self.Bind(wx.EVT_MENU, self.OnMenuDimen, self.menuDimen)
        self.Bind(wx.EVT_MENU, self.OnMenuClearImage, self.menuClearImage)
        self.Bind(wx.EVT_MENU, self.OnMenuHowTo, self.menuHowTo)
        self.Bind(wx.EVT_MENU, self.OnMenuAbout, self.menuAbout)
        self.Bind(wx.EVT_TOGGLEBUTTON, self.OnToggleVicon, self.toggleVicon)
        self.Bind(wx.EVT_BUTTON, self.OnButtonImage, self.buttonImage)
        self.Bind(wx.EVT_TOGGLEBUTTON, self.OnToggleAddPoint, self.toggleAddPoint)
        self.Bind(wx.EVT_TOGGLEBUTTON, self.OnToggleDeletePoint, self.toggleDeletePoint)
        self.Bind(wx.EVT_BUTTON, self.OnButtonEnterPoint, id=wx.ID_OK)
        self.Bind(wx.EVT_TOGGLEBUTTON, self.OnToggleDimen, self.toggleDimen)
        self.Bind(wx.EVT_BUTTON, self.OnButtonSave, self.buttonSave)
        # end wxGlade
        
        # Check that regionEditor object was passed in correctly
        if len(args) > 0 and isinstance(args[0], regionEditor):
            self.parent = args[0]
            if not self.parent.regions:
                print "No regions defined. Exiting calibration."
                self.Destroy()
        else:
            print "No regionEditor object passed in. Exiting calibration."
            self.Destroy()
        
        # Bind mouse events
        self.map.Bind(wx.EVT_LEFT_DOWN, self.OnMapMouseLeftDown, self.map)
        self.map.Bind(wx.EVT_LEFT_UP, self.OnMapMouseLeftUp, self.map)
        self.map.Bind(wx.EVT_MOUSEWHEEL, self.OnMapMouseWheel, self.map)
        self.map.Bind(wx.EVT_ENTER_WINDOW, self.OnMapEnterWindow, self.map)
        self.map.Bind(wx.EVT_LEAVE_WINDOW, self.OnMapLeaveWindow, self.map)
        self.ref.Bind(wx.EVT_LEFT_DOWN, self.OnRefMouseLeftDown, self.ref)
        self.ref.Bind(wx.EVT_LEFT_UP, self.OnRefMouseLeftUp, self.ref)
        self.ref.Bind(wx.EVT_MOUSEWHEEL, self.OnRefMouseWheel, self.ref)
        self.ref.Bind(wx.EVT_ENTER_WINDOW, self.OnRefEnterWindow, self.ref)
        self.ref.Bind(wx.EVT_LEAVE_WINDOW, self.OnRefLeaveWindow, self.ref)
        
        # Bind keyboard events
        self.Bind(wx.EVT_KEY_DOWN, self.OnKeyDown, self)
        self.map.Bind(wx.EVT_KEY_DOWN, self.OnKeyDown, self.map)
        self.ref.Bind(wx.EVT_KEY_DOWN, self.OnKeyDown, self.ref)
        
        # Add close event handler to cleanup before closing
        self.Bind(wx.EVT_CLOSE, self.OnClose)
        
        # Determine mapping of the map panel to the field
        # Avoid difficulties by having same scale for x and y
        mapLen = self.map.GetSize() # Initial size of map panel (pixels)
        # Initial range of field (xmin, xmax, ymin, ymax)
        xmin, xmax, ymin, ymax = self.parent.GetMapBoundaries()
        # pose = pixPose * scale + offset
        # Note: y-pixels and y-pose have opposite directions
        xScale = (xmax - xmin) / float(mapLen[0])
        yScale = (ymax - ymin) / float(mapLen[1])
        maxScale = max(xScale, yScale)
        xOffset = xmin
        yOffset = ymax
        self.mapScale = Point(maxScale, -maxScale)
        self.mapOffset = Point(xOffset, yOffset)
        # Determine initial mapping of the reference panel to the field
        # Initially defines a 1:1 mapping (at least scale/offset-wise) to map
        refLen = self.ref.GetSize() # Initial size of reference panel (pixels)
        xScale = (xmax - xmin) / float(refLen[0])
        yScale = (ymax - ymin) / float(refLen[1])
        maxScale = max(xScale, yScale)
        xOffset = xmin
        yOffset = ymax
        self.refScale = Point(maxScale, -maxScale)
        self.refOffset = Point(xOffset, yOffset)
        
        # Calibration-related parameters
        self.calibPoints = []       # List of lists of Points
                                    # matching map to reference positions
                                    # [[mapPt1, refPt1], [mapPt2, refPt2], ...]
        self.newCalibPt = [None, None]  # List of two points
                                        # for creating new calibration points
                                        # [mapNewPt, refNewPt]
        
        # Mouse-related parameters
        self.mapLeftClickPt = Point(0.0, 0.0)
        self.refLeftClickPt = Point(0.0, 0.0)
        self.selectedPoints = []    # Points that have been selected by mouse
        tolerance = 5.0             # Pixel tolerance to consider "same point"
        self.mapTolerance = tolerance * self.mapScale.x
        self.refTolerance = tolerance * self.refScale.x
        
        # Set up for undo/redo capabilities
        # TODO: Disable self.menuUndo and self.menuRedo
        self.unredoBufLen = 50
        self.undoActions = collections.deque()
        self.redoActions = collections.deque()
        
        # Create Vicon listener
        self.markerPoses = []   # Marker positions to be drawn
        self.viconListener = ViconMarkerListener(self)
        
        # Display the GUI window and set up the map canvas
        self.Show()
        self.RedrawMap()
        
    
    def __set_properties(self):
        # begin wxGlade: CalibrationFrame.__set_properties
        self.SetTitle("Map Calibration")
        self.SetBackgroundColour(wx.Colour(240, 240, 240))
        self.toggleVicon.SetMinSize((50, 50))
        self.buttonImage.SetMinSize((50, 50))
        self.toggleAddPoint.SetMinSize((50, 50))
        self.toggleDeletePoint.SetMinSize((50, 50))
        self.textEnterPointX.SetMinSize((40, 25))
        self.textEnterPointX.SetToolTipString("x")
        self.textEnterPointY.SetMinSize((40, 25))
        self.textEnterPointY.SetToolTipString("y")
        self.buttonEnterPoint.SetMinSize((25, 25))
        self.toggleDimen.SetMinSize((50, 50))
        self.buttonSave.SetMinSize((50, 50))
        self.chkbxShear.SetValue(1)
        self.sidebar.SetMinSize((110, 268))
        self.map.SetMinSize((600, 300))
        self.map.SetBackgroundColour(wx.Colour(255, 255, 255))
        self.ref.SetMinSize((600, 300))
        self.ref.SetBackgroundColour(wx.Colour(255, 255, 255))
        # end wxGlade

    def __do_layout(self):
        # begin wxGlade: CalibrationFrame.__do_layout
        sizer_6 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_7 = wx.BoxSizer(wx.VERTICAL)
        sizer_8 = wx.BoxSizer(wx.VERTICAL)
        sizer_12 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_11 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_10 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_9 = wx.BoxSizer(wx.HORIZONTAL)
        sizer_9.Add(self.toggleVicon, 0, wx.RIGHT | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)
        sizer_9.Add(self.buttonImage, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_8.Add(sizer_9, 1, wx.TOP | wx.BOTTOM | wx.EXPAND, 5)
        sizer_10.Add(self.toggleAddPoint, 0, wx.RIGHT | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)
        sizer_10.Add(self.toggleDeletePoint, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_8.Add(sizer_10, 1, wx.TOP | wx.BOTTOM | wx.EXPAND, 5)
        sizer_11.Add(self.textEnterPointX, 0, wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_11.Add(self.textEnterPointY, 0, wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_11.Add(self.buttonEnterPoint, 0, wx.ALIGN_RIGHT | wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_8.Add(sizer_11, 1, wx.TOP | wx.BOTTOM | wx.EXPAND, 5)
        sizer_12.Add(self.toggleDimen, 0, wx.RIGHT | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)
        sizer_12.Add(self.buttonSave, 0, wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 0)
        sizer_8.Add(sizer_12, 1, wx.EXPAND, 0)
        sizer_8.Add(self.chkbxShear, 0, wx.TOP | wx.BOTTOM | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)
        self.sidebar.SetSizer(sizer_8)
        sizer_6.Add(self.sidebar, 0, 0, 0)
        sizer_7.Add(self.map, 1, wx.BOTTOM | wx.EXPAND, 3)
        sizer_7.Add(self.ref, 1, wx.TOP | wx.EXPAND, 3)
        sizer_6.Add(sizer_7, 1, wx.EXPAND, 0)
        self.SetSizer(sizer_6)
        sizer_6.Fit(self)
        self.Layout()
        # end wxGlade
    
    def OnClose(self, event):
        """Perform cleanup tasks and close the application."""
        self.viconListener.stop()
        self.Destroy()
        
    def OnMenuReset(self, event):  # wxGlade: CalibrationFrame.<event_handler>
        """Clear all calibration points, background images, and markers."""
        self.OnMenuClearMarkers(None)
        self.OnMenuClearImage(None)
        self.OnMenuClearAll(None)
    
    def OnMenuSave(self, event):  # wxGlade: CalibrationFrame.<event_handler>
        """Performs calibration on regions using calibration points to
        calculate a transformation matrix that includes rotation. Moves all the
        region points as appropriate, then close this GUI."""
        # Check that sufficient number of calibration points have been defined
        if len(self.calibPoints) < 3:
            msg = "Calibration requires that at least 3 calibration " + \
                "points are defined. Please define more points."
            notifyDialog = wx.MessageDialog(self, msg, \
                style=wx.OK|wx.ICON_EXCLAMATION|wx.STAY_ON_TOP)
            notifyDialog.ShowModal()
            notifyDialog.Destroy()
            return
        
        # Put calibration points into desired format
        mapPts = numpy.mat([self.calibPoints[0][0].x, \
            self.calibPoints[0][0].y]).T
        regPts = numpy.mat([self.calibPoints[0][1].x, \
            self.calibPoints[0][1].y]).T
        for ptPair in self.calibPoints:
            mapPts = numpy.hstack([mapPts, \
                numpy.mat([ptPair[0].x, ptPair[0].y]).T])
            regPts = numpy.hstack([regPts, \
                numpy.mat([ptPair[1].x, ptPair[1].y]).T])
        
        # Shearing allows for the scaling of dimensions independently
        # (does not keep the aspect ratio) but also skews angles and such
        # if the points chosen are not perfect
        allowShear = not self.chkbxShear.IsChecked()
        
        # Get tranformation matrix such that
        # regPt = T * mapPt
        T = _transformations.affine_matrix_from_points(mapPts, regPts, \
            shear=allowShear)
        
        # Apply transformation to all region points
        # TODO: Add this to undo in regionEditor somehow
        for reg in self.parent.regions:
            for pt in reg.verts:
                ptMat = numpy.mat([pt.x, pt.y, 1.0]).T
                newPtMat = T * ptMat
                pt.Set(float(newPtMat[0]), float(newPtMat[1]))
        self.parent.RedrawCanvas()
        
        # Quit calibration
        self.OnClose(None)

    def OnMenuExit(self, event):  # wxGlade: CalibrationFrame.<event_handler>
        self.OnClose(None)

    def OnMenuUndo(self, event):  # wxGlade: CalibrationFrame.<event_handler>
        print "Event handler `OnMenuUndo' not implemented!"
        event.Skip()

    def OnMenuRedo(self, event):  # wxGlade: CalibrationFrame.<event_handler>
        print "Event handler `OnMenuRedo' not implemented!"
        event.Skip()

    def OnMenuSelectAll(self, event):  # wxGlade: CalibrationFrame.<event_handler>
        print "Event handler `OnMenuSelectAll' not implemented!"
        event.Skip()

    def OnMenuClearAll(self, event):  # wxGlade: CalibrationFrame.<event_handler>
        print "Event handler `OnMenuClearAll' not implemented!"
        event.Skip()

    def OnMenuShowMarkers(self, event):  # wxGlade: CalibrationFrame.<event_handler>
        # Switch Vicon streaming on or off based on state of menu checkbox
        if self.menuShowMarkers.IsChecked():
            self.toggleVicon.SetValue(True)
            self.viconListener.start()
        else:
            self.viconListener.stop()
            # Reinitialize thread to enable restarting it
            self.viconListener = ViconMarkerListener(self)
            self.toggleVicon.SetValue(False)

    def OnMenuClearMarkers(self, event):  # wxGlade: CalibrationFrame.<event_handler>
        if self.menuShowMarkers.IsChecked():
            self.toggleVicon.SetValue(False)
            self.menuShowMarkers.Check(False)
            self.viconListener.stop()
            self.viconListener = ViconMarkerListener(self)
            time.sleep(0.1)
        self.markerPoses = []
        self.RedrawVicon()

    def OnMenuLoadImage(self, event):  # wxGlade: CalibrationFrame.<event_handler>
        print "Event handler `OnMenuLoadImage' not implemented!"
        event.Skip()
    
    def OnMenuDimen(self, event):  # wxGlade: CalibrationFrame.<event_handler>
        print "OnMenuDimen"
        event.Skip()

    def OnMenuClearImage(self, event):  # wxGlade: CalibrationFrame.<event_handler>
        print "Event handler `OnMenuClearImage' not implemented!"
        event.Skip()

    def OnMenuHowTo(self, event):  # wxGlade: CalibrationFrame.<event_handler>
        print "Event handler `OnMenuHowTo' not implemented!"
        event.Skip()

    def OnMenuAbout(self, event):  # wxGlade: CalibrationFrame.<event_handler>
        print "Event handler `OnMenuAbout' not implemented!"
        event.Skip()

    def OnToggleVicon(self, event):  # wxGlade: CalibrationFrame.<event_handler>
        # Switch Vicon streaming on or off based on state of toggle button
        if self.toggleVicon.GetValue():
            self.menuShowMarkers.Check(True)
            self.viconListener.start()
        else:
            self.viconListener.stop()
            # Reinitialize thread to enable restarting it
            self.viconListener = ViconMarkerListener(self)
            self.menuShowMarkers.Check(False)

    def OnButtonImage(self, event):  # wxGlade: CalibrationFrame.<event_handler>
        print "Event handler `OnButtonImage' not implemented!"
        event.Skip()
    
    def OnToggleAddPoint(self, event):  # wxGlade: CalibrationFrame.<event_handler>
        self.ResetToggles(toggleKeep=self.toggleAddPoint)
        # TODO: When menu items are added for add point, flip on here
    
    def OnToggleDeletePoint(self, event):  # wxGlade: CalibrationFrame.<event_handler>
        self.ResetToggles(toggleKeep=self.toggleDeletePoint)
        # TODO: When menu items are added for delete point, flip on here

    def OnButtonEnterPoint(self, event):  # wxGlade: CalibrationFrame.<event_handler>
        print "Event handler `OnButtonEnterPoint' not implemented"
        event.Skip()

    def OnToggleDimen(self, event):  # wxGlade: CalibrationFrame.<event_handler>
        print "Event handler `OnToggleDimen' not implemented"
        event.Skip()
    
    def OnButtonSave(self, event):  # wxGlade: CalibrationFrame.<event_handler>
        self.OnMenuSave(None)
    
    def OnMapMouseLeftDown(self, event):
        """Save downclick point on map for future use."""
        self.mapLeftClickPt, iCalibPt, iReg = \
            self.SnapPointMap(self.MapPix2M(event.GetPosition()))
    
    def OnMapMouseLeftUp(self, event):
        """React to the finalization of the left click on the map."""
        ptPix = event.GetPosition()
        pt, iCalibPt, iReg = \
            self.SnapPointMap(self.MapPix2M(ptPix))
        
        # Creating a calibration point
        if self.toggleAddPoint.GetValue() and iCalibPt == -1:
            # First point clicked for adding new point
            if not self.newCalibPt[1]:
                self.newCalibPt[0] = pt
                self.RedrawMap()
            
            # Finalizing calibration point (second point clicked)
            else:
                self.calibPoints.append([pt, self.newCalibPt[1]])
                self.newCalibPt = [None, None]
                self.Redraw()
        
        # Removing a calibration point
        elif self.toggleDeletePoint.GetValue() and iCalibPt != -1:
            self.calibPoints.pop(iCalibPt)
            self.Redraw()
        
        # Panning the map view
        elif pt.Dist(self.mapLeftClickPt) > self.mapTolerance:
            downClickPix = self.MapM2Pix(self.mapLeftClickPt)
            self.mapOffset = Point(self.mapScale.x * \
                (downClickPix[0] - ptPix[0]) + self.mapOffset.x, \
                self.mapScale.y * (downClickPix[1] - ptPix[1]) + \
                self.mapOffset.y)
            self.RedrawMap()
    
    def OnMapMouseWheel(self, event):
        """Zoom on the map."""
        ptPix = event.GetPosition()
        rot = event.GetWheelRotation()          # Usually +/- multiple of 120
        scaler = 0.75 ** (rot / 120)            # Zoom in to 75% per scroll
        # Keep mouse on the same point after zooming
        # pt = ptPix * scale + offset
        # pt = ptPix * scaleNew + offsetNew
        self.mapOffset = Point(float(ptPix[0]) * self.mapScale.x * \
            (1 - scaler) + self.mapOffset.x, float(ptPix[1]) * \
            self.mapScale.y * (1 - scaler) + self.mapOffset.y)
        self.mapScale = self.mapScale * scaler
        self.RedrawMap()
    
    def OnMapEnterWindow(self, event):
        """Set focus on map to enable zooming."""
        self.map.SetFocus()
        self.RedrawMap()
    
    def OnMapLeaveWindow(self, event):
        """Return focus to main GUI."""
        self.SetFocus()
    
    def OnRefMouseLeftDown(self, event):
        """Save downclick point on reference panel for future use."""
        self.refLeftClickPt, iCalibPt, iReg = \
            self.SnapPointMap(self.RefPix2M(event.GetPosition()))
    
    def OnRefMouseLeftUp(self, event):
        """React to the finalization of the left click on the map."""
        ptPix = event.GetPosition()
        pt, iCalibPt = \
            self.SnapPointRef(self.RefPix2M(ptPix))
        
        # Creating a calibration point
        if self.toggleAddPoint.GetValue() and iCalibPt == -1:
            # First point clicked for adding new point
            if not self.newCalibPt[0]:
                self.newCalibPt[1] = pt
                self.RedrawMap()
            
            # Finalizing calibration point (second point clicked)
            else:
                self.calibPoints.append([self.newCalibPt[0], pt])
                self.newCalibPt = [None, None]
                self.Redraw()
        
        # Removing a calibration point
        elif self.toggleDeletePoint.GetValue() and iCalibPt != -1:
            self.calibPoints.pop(iCalibPt)
            self.Redraw()
        
        # Panning the reference view
        elif pt.Dist(self.refLeftClickPt) > self.refTolerance:
            downClickPix = self.RefM2Pix(self.refLeftClickPt)
            self.refOffset = Point(self.refScale.x * \
                (downClickPix[0] - ptPix[0]) + self.refOffset.x, \
                self.refScale.y * (downClickPix[1] - ptPix[1]) + \
                self.refOffset.y)
            self.RedrawRef()
    
    def OnRefMouseWheel(self, event):
        """Zoom on the reference panel."""
        ptPix = event.GetPosition()
        rot = event.GetWheelRotation()          # Usually +/- multiple of 120
        scaler = 0.75 ** (rot / 120)            # Zoom in to 75% per scroll
        # Keep mouse on the same point after zooming
        # pt = ptPix * scale + offset
        # pt = ptPix * scaleNew + offsetNew
        self.refOffset = Point(float(ptPix[0]) * self.refScale.x * \
            (1 - scaler) + self.refOffset.x, float(ptPix[1]) * \
            self.refScale.y * (1 - scaler) + self.refOffset.y)
        self.refScale = self.refScale * scaler
        self.RedrawRef()
    
    def OnRefEnterWindow(self, event):
        """Set focus on reference panel to enable zooming."""
        self.ref.SetFocus()
        self.RedrawRef()
    
    def OnRefLeaveWindow(self, event):
        """Return focus to main GUI."""
        self.SetFocus()
    
    def OnKeyDown(self, event):
        print "OnKeyDown"
        event.Skip()
    
    def Redraw(self):
        """Redraw map and reference panels."""
        self.RedrawMap()
        self.RedrawRef()
    
    def RedrawMap(self):
        """Redraw the map panel."""
        # Clear map
        self.map.ClearBackground()
        
        # Create device context
        windc = wx.WindowDC(self.map)
        dc = wx.GCDC(windc)
        self.map.PrepareDC(dc)
        dc.BeginDrawing()
        
        # Redraw all regions
        for region in self.parent.regions:
            self.DrawRegion(region, dc=dc)
        
        # Draw calibration points
        for iPtPair, ptPair in enumerate(self.calibPoints):
            self.DrawCalibPoint(self.MapM2Pix(ptPair[0]), str(iPtPair), dc)
        
        # Draw single point from currently being made calibration point
        if self.newCalibPt[0]:
            self.DrawCalibPoint(self.MapM2Pix(self.newCalibPt[0]), "", dc)
        
        dc.EndDrawing()
    
    def RedrawRef(self):
        """Redraw the reference panel."""
        # Clear ref
        self.ref.ClearBackground()
        
        # Create device context
        windc = wx.WindowDC(self.ref)
        dc = wx.GCDC(windc)
        self.ref.PrepareDC(dc)
        dc.BeginDrawing()
        
        # TODO: Draw background image
        
        # Draw calibration points
        for iPtPair, ptPair in enumerate(self.calibPoints):
            self.DrawCalibPoint(self.RefM2Pix(ptPair[1]), str(iPtPair), dc)
        
        # Draw single point from currently being made calibration point
        if self.newCalibPt[1]:
            self.DrawCalibPoint(self.RefM2Pix(self.newCalibPt[1]), "", dc)
        
        # Draw markers
        dc.SetBrush(wx.Brush(wx.Colour(255, 255, 255, 128), wx.SOLID))
        dc.SetPen(wx.Pen(wx.Colour(0, 0, 0, 125), 1, wx.SOLID))
        for pt in self.markerPoses:
            ptPix = self.RefM2Pix(pt)
            dc.DrawCircle(ptPix[0], ptPix[1], 4)
        
        dc.EndDrawing()
    
    def RedrawVicon(self):
        # TODO: Redraw saved image of background since it is faster and 
        #       vicon needs to be redrawn at a high frequency
        self.RedrawRef()
    
    def DrawRegion(self, region, dc):
        """Draw a single region.

        region - Instance of Region class, contains information about the region.
        dc - Device context used for drawing on the panel.
        """
        # Set brush to region color
        isBoundary = region.name.lower() == "boundary"
        if isBoundary:
            dc.SetBrush(wx.Brush(region.color, wx.TRANSPARENT))
            dc.SetPen(wx.Pen(wx.BLACK, 3, wx.SOLID))
        elif region.isObstacle:
            obstColor = wx.Colour(region.color.Red() / 10, \
                region.color.Green() / 10, region.color.Blue() / 10, 128)
            dc.SetBrush(wx.Brush(obstColor, wx.SOLID))
            dc.SetPen(wx.Pen(region.color, 1, wx.SOLID))
        else:
            innerColor = wx.Colour(region.color.Red(), region.color.Green(), \
                region.color.Blue(), 128)
            dc.SetBrush(wx.Brush(innerColor, wx.SOLID))
            dc.SetPen(wx.Pen(region.color, 1, wx.SOLID))
        dc.SetTextForeground(wx.BLACK)
        dc.SetBackgroundMode(wx.TRANSPARENT)
        dc.SetFont(wx.Font(10, wx.FONTFAMILY_SWISS, wx.NORMAL, wx.BOLD, False))
        
        # Set up label
        if region.isObstacle:
            labelText = "(%s)" % region.name
        else:
            labelText = region.name
        labelWidth, labelHeight = dc.GetTextExtent(labelText)
        
        # Draw region
        vertsPix = []
        xLabelPix = 0
        yLabelPix = 0
        for vert in region.verts:
            vertPix = self.MapM2Pix(vert)
            vertsPix.append(vertPix)
            if not isBoundary:          # Put label in center
                xLabelPix += vertPix[0]
                yLabelPix += vertPix[1]
            else:                       # Put label in lower right corner
                xLabelPix = max(xLabelPix, vertPix[0])
                yLabelPix = max(yLabelPix, vertPix[1])
        dc.DrawPolygon(vertsPix)
        if isBoundary:
            xLabelPix = xLabelPix - labelWidth
        else:
            xLabelPix = xLabelPix / len(region.verts) - labelWidth / 2
            yLabelPix = yLabelPix / len(region.verts) - labelHeight / 2
        
        # Draw label
        if not isBoundary:
            dc.SetBrush(wx.Brush(region.color, wx.SOLID))
            dc.DrawRoundedRectangle(xLabelPix - 5, yLabelPix - 3, \
                labelWidth + 10, labelHeight + 6, 3)
        dc.DrawText(labelText, xLabelPix, yLabelPix)
    
    def DrawCalibPoint(self, ptPix, label, dc):
        """Draw a single calibration point.
        
        ptPix - Point to draw with coordinates in pixels
        label - String to label point with - usually point index
                If label is empty, point will be drawn in a differnt color
        dc - Device context that allows for drawing
        """
        # Draw circle
        radius = 5
        if label:
            innerColor = wx.RED
        else:
            innerColor = wx.GREEN
        dc.SetBrush(wx.Brush(innerColor, wx.SOLID))
        dc.SetPen(wx.Pen(wx.BLACK, 1, wx.SOLID))
        dc.DrawCircle(ptPix[0], ptPix[1], radius)
        
        # Draw label
        if label:
            dc.SetTextForeground(wx.BLACK)
            dc.SetBackgroundMode(wx.TRANSPARENT)
            dc.SetFont(wx.Font(8, wx.FONTFAMILY_SWISS, wx.NORMAL, wx.BOLD, False))
            labelWidth, labelHeight = dc.GetTextExtent(label)
            xLabelPix = ptPix[0] - radius
            yLabelPix = ptPix[1] - radius
            dc.DrawText(label, xLabelPix, yLabelPix)
    
    def ResetToggles(self, toggleKeep=None):
        """Unpress toggle buttons except that specified. Reset calibration
        point creation. Redraw the panels.
        
        toggleKeep - Toggle button to retain the value of
        """
        # Reset toggles
        valueKeep = toggleKeep.GetValue()
        self.toggleAddPoint.SetValue(False)
        self.toggleDeletePoint.SetValue(False)
        self.toggleDimen.SetValue(False)
        toggleKeep.SetValue(valueKeep)
        
        # Reset partial calibration point creation
        self.newCalibPt = [None, None]
        
        # Redraw the map and reference panels
        self.Redraw()
    
    def SnapPointMap(self, pt):
        """Snap the point to the closest calibration point, region vertex, or
        region edge from the map panel.
        
        pt - Point to snap in absolute coordinates
        returns - (snappedPt, idxCalibPt, idxReg)
            snappedPt - Point after snapping, in absolute coordinates
            idxCalibPt - Index of snapped-to calibration point
                       (-1 if not snapped to calibration point)
            idxReg - Index of region snapped-to (-1 if not snapped to region)
        """
        # Check calibration points first
        snapped = False
        pt, idxCalibPt, snapped = \
            self.SnapCalibPoints(pt, 0, snapped=snapped)
        
        # Check regions next
        pt, idxReg, idxRPoint, idxREdge, snapped = \
            self.parent.SnapRegions(pt, snapped=snapped)
        
        return pt, idxCalibPt, idxReg
    
    def SnapPointRef(self, pt):
        """Snap the point to the closest calibration point or marker from the
        reference panel.
        
        pt - Point to snap in absolute coordinates
        returns - (snappedPt, iCalibPt, iReg)
            snappedPt - Point after snapping, in absolute coordinates
            idxCalibPt - Index of snapped-to calibration point
                       (-1 if not snapped to calibration point)
        """
        # Check calibration points first
        snapped = False
        pt, idxCalibPt, snapped = \
            self.SnapCalibPoints(pt, 1, snapped=snapped)
        
        # Check marker points next
        pt, snapped = self.SnapVicon(pt, snapped=snapped)
        
        return pt, idxCalibPt
    
    def SnapCalibPoints(self, pt, idxPanel, snapped=False):
        """Snap the point to the first sufficiently close calibration point in
        the specified panel.
        
        pt - Point to be snapped in absolute coordinates
        idxPanel - 0 indicating map panel, 1 indicating reference panel
        snapped - Boolean, whether point has been snapped already
                  If snapped was true in input, then function will immediately
                  return, setting the same value to the output snapped
        returns - (snappedPt, idxCalibPt, snapped)
            snappedPt - Point after snapping, in absolute coordinates
            idxCalibPt - Index of snapped-to calibration point
                         (-1 if not snapped to calibration point)
            snapped - Boolean indicating if the point has ever been snapped
        """
        # Set tolerance in absolute coordinates
        if idxPanel == 0:
            tol = self.mapTolerance
        else:
            tol = self.refTolerance
        
        # Check through all calibration points until snapping
        idxCalibPt = -1
        iCPt = len(self.calibPoints) - 1
        while not snapped and iCPt > -1:
            if pt.Dist(self.calibPoints[iCPt][idxPanel]) < tol:
                pt = self.calibPoints[iCPt][idxPanel]
                idxCalibPt = iCPt
                snapped = True
            iCPt -= 1
        
        return copy.copy(pt), idxCalibPt, snapped
    
    def SnapVicon(self, pt, snapped=False):
        """Snap the given point to any sufficiently close marker point.
        
        pt - Point to be snapped, in absolute coordinates
        snapped - Boolean, indicates if point has already been snapped
                  If snapped was true in input, then function will immediately
                  return, setting the same value to the output snapped
        returns - (snappedPt, snapped)
            snappedPt - Point after snapping
            snapped - Boolean, indicates if point has ever been snapped
        """
        # Check all points until snapped
        iVPt = 0
        while not snapped and iVPt < len(self.markerPoses):
            if pt.Dist(self.markerPoses[iVPt]) < self.refTolerance:
                pt = copy.copy(self.markerPoses[iVPt])
                snapped = True
            iVPt += 1
        
        return copy.copy(pt), snapped
    
    def MapM2Pix(self, pose):
        """Convert from absolute (meter) coordinates to pixel coordinates for
        the map panel.
        
        pose - Point, absolute coordinates of point
        returns - Tuple, pixel coordinates in canvas panel (col, row)
        """
        col = int((pose.x - self.mapOffset.x) / self.mapScale.x)
        row = int((pose.y - self.mapOffset.y) / self.mapScale.y)
        return (col, row)
    
    def MapPix2M(self, pixPose):
        """Convert from pixel coordinates to absolute (meter) coordinates for
        the map panel.
        
        pixPose - Tuple, pixel coordinates in canvas panel (col, row)
        returns - Point, absolute coordinates of point
        """
        x = float(pixPose[0]) * self.mapScale.x + self.mapOffset.x
        y = float(pixPose[1]) * self.mapScale.y + self.mapOffset.y
        return Point(x, y)
    
    def RefM2Pix(self, pose):
        """Convert from absolute (meter) coordinates to pixel coordinates for
        the reference panel.
        
        pose - Point, absolute coordinates of point
        returns - Tuple, pixel coordinates in canvas panel (col, row)
        """
        col = int((pose.x - self.refOffset.x) / self.refScale.x)
        row = int((pose.y - self.refOffset.y) / self.refScale.y)
        return (col, row)
    
    def RefPix2M(self, pixPose):
        """Convert from pixel coordinates to absolute (meter) coordinates for
        the reference panel.
        
        pixPose - Tuple, pixel coordinates in canvas panel (col, row)
        returns - Point, absolute coordinates of point
        """
        x = float(pixPose[0]) * self.refScale.x + self.refOffset.x
        y = float(pixPose[1]) * self.refScale.y + self.refOffset.y
        return Point(x, y)
# end of class CalibrationFrame

class Region:
    def __init__(self, points=[], name="", holes=[], rgb=None, obst=False):
        """Create an object to represent a region.

        points - List of Points containing vertex information
                 [Point(x1, y1), Point(x2, y2), ...]
        name - String defining region name
        holes - List of lists of points representing holes cut in the region
        rgb - List of integers defining color
              [red, green, blue], each with value in range [0 255]
        obst - Boolean, True indicates that the region is an obstacle
        """
        # TODO: Add convex/concave
        self.verts = points
        self.name = name
        self.holeList = holes
        if not rgb:
            rgb = [random.randint(0, 255), random.randint(0, 255), \
                random.randint(0,255)]
        self.color = wx.Colour(rgb[0], rgb[1], rgb[2])
        self.isObstacle = obst
    
    def __str__(self):
        """Representation of object."""
        s = "%s\t{%03d\t%03d\t%03d}\t[" % (self.name, self.color.Red(), \
            self.color.Green(), self.color.Blue())
        for iPt, pt in enumerate(self.verts):
            s += str(pt)
            if iPt < len(self.verts) - 1:
                s += "\t"
        s += "]"
        return s
    
    def getData(self):
        """Return a copy of the object's internal data.
        This is used to save this region to disk.
        """

        data = {'name': self.name, 'color': (self.color.Red(), \
            self.color.Green(), self.color.Blue())}
        
        data['points'] = [(pt.x, pt.y) for pt in self.verts]
        
        data['holeList'] = []
        for hole in self.holeList:
            data['holeList'].append([(pt.x, pt.y) for pt in hole])

        data['isObstacle'] = self.isObstacle

        return data

    def setData(self, data):
        """Set the object's internal data.
        
        'data' is a copy of the object's saved data, as returned by
        getData() above. This is used to restore a previously saved region.
        """
        
        self.name = data['name']
        self.color = wx.Colour(*data['color'])
        
        self.verts = [Point(*pt) for pt in data['points']]
        
        if 'holeList' in data:
            self.holeList = []
            for hole in data['holeList']:
                self.holeList.append([Point(*pt) for pt in hole])
        
        if 'isObstacle' in data:
            self.isObstacle = data['isObstacle']
    
    def PtInRegion(self, pt):
        """Check if a point is inside of the region.
        Algorithm taken from C# version of Solution 1 from
        http://local.wasp.uwa.edu.au/~pbourke/geometry/insidepoly/
        
        pt - Point to check
        returns - Boolean, True if the point is inside of the region
        """
        result = False
        n = len(self.verts)
        for i in range(n):
            j = (i + 1) % n
            if ((self.verts[j].y <= pt.y and pt.y < self.verts[i].y) or \
                    (self.verts[i].y <= pt.y and pt.y < self.verts[j].y)) and \
                    pt.x < (self.verts[i].x - self.verts[j].x) * \
                    (pt.y - self.verts[j].y) / \
                    (self.verts[i].y - self.verts[j].y) + self.verts[j].x:
                result = not result
        return result
# end of class Region


class Action:
    def __init__(self, regions, adjacent):
        """Create an object that represents an (un/re)doable action.
        Deep copies are used to avoid retaining same state when state changes.
        
        regions - Regions array before the action was taken.
        adjacent - Adjacencies matrix before the action was taken.
        """
        self.stateRegions = copy.deepcopy(regions)
        self.stateAdjacent = copy.deepcopy(adjacent)
# end of class Action


class Point:
    def __init__(self, x, y):
        """Create an object that allows floating point vector operations.

        x - Float, first coordinate of point
        y - Float, second coordinate of point
        """
        if isinstance(x, float) and isinstance(y, float):
            self.x = x
            self.y = y
        else:
            raise TypeError('\'Point\' creation takes only \'float\' values')

    def __str__(self):
        """Representation of object."""
        return '(%.3f\t%.3f)' % (self.x, self.y)

    def __hash__(self):
        """Hashtable representation of object."""
        tup = (self.x, self.y)
        return tup.__hash__()

    def __eq__(self, other):
        """Checks equality (self == other)."""
        return isinstance(other, Point) and self.x == other.x and self.y == other.y

    def __ne__(self, other):
        """Checks non-equality (self != other)."""
        return not self.__eq__(other)

    def __add__(self, other):
        """Addition operator (self + other)."""
        if isinstance(other, Point):
            return Point(self.x + other.x, self.y + other.y)
        elif isinstance(other, tuple) and len(other) == 2:
            return Point(self.x + other[0], self.y + other[1])
        else:
            raise TypeError('cannot add \'Point\' and \'' + \
                other.__class__.__name__ + '\' objects')

    def __radd__(self, other):
        """Right addition operator (other + self)."""
        return self.__add__(other)

    def __sub__(self, other):
        """Subtraction operator (self - other)."""
        if isinstance(other, Point):
            return Point(self.x - other.x, self.y - other.y)
        elif isinstance(other, tuple) and len(other) == 2:
            return Point(self.x - other[0], self.y - other[1])
        else:
            raise TypeError('cannot subtract \'Point\' and \'' + \
                other.__class__.__name__ + '\' objects')

    def __rsub__(self, other):
        """Right subtraction operator (other - self)."""
        if isinstance(other, Point):
            return Point(other.x - self.x, other.y - self.y)
        elif isinstance(other, tuple) and len(other) == 2:
            return Point(other[0] - self.x, other[1] - self.y)
        else:
            raise TypeError('cannot subtract \'Point\' and \'' + \
                other.__class__.__name__ + '\' objects')

    def __mul__(self, other):
        """Multiplication operator (self * other)."""
        if isinstance(other, float):
            return Point(self.x * other, self.y * other)
        else:
            raise TypeError('cannot multiply \'Point\' and \'' + \
                other.__class__.__name__ + '\' objects')

    def __rmul__(self, other):
        """Right multiplication operator (other * self)."""
        return self.__mul__(other)

    def __div__(self, other):
        """Division operator (self / other)."""
        if isinstance(other, float):
            return Point(self.x / other, self.y / other)
        else:
            raise TypeError('cannot divide \'Point\' and \'' + \
                other.__class__.__name__ + '\' objects')

    def __truediv__(self, other):
        """True division operator."""
        return self.__div__(other)
    
    def Set(self, x, y):
        """Change the value of the point."""
        self.x = x
        self.y = y

    def Dot(self, other):
        """Dot product."""
        if isinstance(other, Point):
            return self.x * other.x + self.y * other.y
        elif isinstance(other, tuple) and len(other) == 2:
            return self.x * other[0] + self.y * other[1]
        else:
            raise TypeError('cannot compute dot product of \'Point\' and \'' + \
                other.__class__.__name__ + '\' object')

    def Dist(self, other):
        """Euclidean distance from this point to the other."""
        if isinstance(other, Point):
            return math.sqrt((self.x - other.x) ** 2 + \
                (self.y - other.y) ** 2)
        elif isinstance(other, tuple) and len(other) == 2:
            return math.sqrt((self.x - other[0]) ** 2 + \
                (self.y - other[1]) ** 2)
        else:
            raise TypeError('cannot compute distance from \'Point\' to \'' + \
                other.__class__.__name__ + '\' object')

    def Norm(self):
        """Length of the vector."""
        return math.sqrt(self.x ** 2 + self.y ** 2)
# end of class Point


class ViconMarkerListener(threading.Thread):
    def __init__(self, parent):
        """Create the a socket to receive Vicon data."""
        super(ViconMarkerListener, self).__init__()

        # Communication parameters
        self.parent = parent        # regionEditor or CalibrationFrame
        self.addr = ("0.0.0.0", 7500)
        self.bufsize = 65536
        self.udpSock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.lock = threading.Lock()
        self.close = threading.Event()
        self.updateFreq = 20    # Hz

        # Tracking parameters
        # TODO: Set all paremeters in configuration of GUI
        self.minDist = 0.01     # Distance to move to qualify as movement
        self.maxDist = 0.1      # Qualified as new point
        self.movMaxTime = 15 * self.updateFreq  # (sec)*(Hz)
                                # Iterations during which marker is not moving
                                # before stopping tracking
        self.invMaxTime = 1 * self.updateFreq   # (sec)*(Hz)
                                # Iterations during which marker is not found
                                # before stopping tracking

        # Tracking containers
        self.oldPoses = []      # Previous marker positions
        self.movingPoses = []   # Markers that are moving
        self.movingTimeout = [] # Iterations left before movement timeout
        self.invisTimeout = []  # Iteractions left before not-found timeout

    def run(self):
        """Open the socket to start communication. Process messages."""
        # Open socket for communication
        self.udpSock.bind(self.addr)

        # Receive communication until stopped
        self.close.clear()
        delay = 1 / self.updateFreq
        while not self.close.isSet():
            self.lock.acquire()
            data = self.udpSock.recv(self.bufsize)
            self.lock.release()
            self.ProcessData(data)
            time.sleep(delay)

        # Close socket
        self.udpSock.close()
        self.oldPoses = []
        self.movingPoses = []
        self.movingTimeout = []
        self.invisTimeout = []

    def stop(self):
        """Close the socket to end UDP communication."""
        self.close.set()

    # Deserialize and save data
    def ProcessData(self, data):
        """Extract marker positions and pass them on to be mapped.

        data - Byte array encoded from multiple pairs of doubles [x1 y1 ...]
        """
        # Check for valid data (not null or incomplete)
        if data and len(data)%16 == 0:
            poses = []
            for i in range(0, len(data), 16):
                x, y = struct.unpack('dd', data[i:i+16])
                poses.append(Point(x, y))
            # Save and plot marker positions
            # Both regionEditor GUI and CalibrationFrame GUI have
            # markerPoses field and RedrawVicon method
            self.parent.markerPoses = poses
            self.UpdateMovingMarkers(poses)
            self.parent.RedrawVicon()      # Force map redraw

    def UpdateMovingMarkers(self, poses):
        """Note which markers are newly moving and update position of old
        moving markers based on change in position from previous list.

        poses - List of Points, marker positions.
        """
        # Not first time through
        if self.oldPoses:
            # Check all currently tracked markers first
            for iMarker, markerPose in enumerate(self.movingPoses):
                closestIdx = self.FindClosest(poses, markerPose)
                closestDist = markerPose.Dist(poses[closestIdx])
                # Same marker
                if closestDist < self.maxDist:
                    self.invisTimeout[iMarker] = self.invMaxTime
                    # Is moving
                    if closestDist > self.minDist:
                        self.movingTimeout[iMarker] = self.movMaxTime + 1
                    self.movingPoses[iMarker] = poses[closestIdx]
                # Marker not seen
                else:
                    self.invisTimeout[iMarker] -= 1
                self.movingTimeout[iMarker] -= 1
                # Marker has stopped moving or not been seen for some time
                if self.invisTimeout[iMarker] == 0 or \
                        self.movingTimeout[iMarker] == 0:
                    self.invisTimeout.pop(iMarker)
                    self.movingTimeout.pop(iMarker)
                    self.movingPoses.pop(iMarker)
            # Check through all new markers next
            for markerPose in poses:
                closestIdx = self.FindClosest(self.oldPoses, markerPose)
                closestDist = markerPose.Dist(self.oldPoses[closestIdx])
                # Point is moving
                if closestDist < self.maxDist and closestDist > self.minDist:
                    self.movingPoses.append(markerPose)
                    self.movingTimeout.append(self.movMaxTime)
                    self.invisTimeout.append(self.invMaxTime)
        self.oldPoses = poses

    def FindClosest(self, points, target):
        """Find the closest point to the target.

        points - List of Points, marker positions.
        target - Point, point to find marker closest to.
        returns - Integer, index of closest point in points.
        """
        # Iterate through all points
        minDist = float('inf')
        minIdx = 0
        for i, pt in enumerate(points):
            dist = target.Dist(pt)
            if dist < minDist:
                minIdx = i
                minDist = dist
        return minIdx
# end of class ViconMarkerListener


class AudioFeedbackThread(threading.Thread):
    def __init__(self, feedbackDialog, regEditor):
        """Create audio feedback for marker placement.

        fbDia - Dialog box that specifies the point of interest.
        regEd - RegionEditor GUI that gets Vicon information.
        """
        super(AudioFeedbackThread, self).__init__()

        # Save other objects
        self.fbDia = feedbackDialog
        self.regEd = regEditor
        
        # Non-audio parameters
        self.close = threading.Event()
        self.tolerance = 0.10   # Close-enough distance (m)
        self.maxDist = 2.5      # Points must be within this to react (m)

        # Audio parameters for beeping
        # Chosen for audibility at distance
        # TODO: Make modifiable by configuration file
        minFreq = 600           # Lowest frequency played (Hz)
        maxFreq = 7000          # Highest frequency played (Hz)
        updateFreq = 2.0        # Frequency of possible sound change (Hz)
        self.duration = int(1000.0 / updateFreq)
        
        # Audio parameters for text-to-speech
        self.engine = pyttsx.init()
        self.engine.setProperty('rate', 120)
        self.engine.setProperty('volume', 1.0)
        self.speechFormat = "X %.1f, Y %.1f"
        self.speechPause = 1.0  # Pause between voice commands

        # Calculate the line representing the distance-frequency mapping
        self.freqSlope = (minFreq - maxFreq) / (self.maxDist - self.tolerance)
        self.freqIntercept = maxFreq - self.tolerance * self.freqSlope

    def run(self):
        """Play sound based on distance of moving marker to goal point."""
        self.close.clear()
        while not self.close.isSet():
            soundOption = self.fbDia.radioboxOption.GetSelection()
            if not self.fbDia.chkbxMute.GetValue():
                # Get distance from closest marker to point of interest
                intPt = self.regEd.regions[self.fbDia.currReg].\
                    verts[self.fbDia.currPt]
                minStatDistToPt = 2.0 * self.maxDist
                for statPt in self.regEd.markerPoses:
                    if not statPt in self.regEd.viconListener.movingPoses:
                        minStatDistToPt = min(minStatDistToPt, intPt.Dist(statPt))

                # Get distance from closest moving point to point of interest
                minDistToPt = 2.0 * self.maxDist
                minPtIdx = -1
                for iPt, movPt in \
                        enumerate(self.regEd.viconListener.movingPoses):
                    dist = intPt.Dist(movPt)
                    if dist < minDistToPt:
                        minDistToPt = dist
                        minPtIdx = iPt

                # Plot moving point and goal point
                dc = wx.WindowDC(self.regEd.canvas)
                dc.SetBrush(wx.Brush(wx.Colour(255, 0, 0, 100), wx.SOLID))
                posePix = self.regEd.Map2Pix(intPt)
                dc.DrawCircle(posePix[0], posePix[1], 8)
                if minPtIdx > -1 and minPtIdx < \
                        len(self.regEd.viconListener.movingPoses):
                    posePix = self.regEd.Map2Pix(\
                        self.regEd.viconListener.movingPoses[minPtIdx])
                    dc.DrawCircle(posePix[0], posePix[1], 8)

                # Close-enough
                if minDistToPt < self.tolerance or \
                        minStatDistToPt < self.tolerance:
                    # Marker is settled
                    if minStatDistToPt < self.tolerance or self.regEd.\
                            viconListener.movingTimeout[minPtIdx] < \
                            self.regEd.viconListener.movMaxTime:
                        # Play "success" sound to indicate done with point
                        if soundOption:
                            time.sleep(0.2)
                            winsound.Beep(600, 200)
                            winsound.Beep(1200, 200)
                            winsound.Beep(1800, 200)
                            time.sleep(0.2)
                        else:
                            self.engine.say("Success, next")
                            self.engine.runAndWait()
                            time.sleep(self.speechPause)
                        # Switch to next point of interest if checked
                        if self.fbDia.chkbxIterate.GetValue():
                            self.fbDia.OnButtonNext(None)
                            # TODO: Check if all points are in correct spots
                            #       and stop if done

                    # Marker not yet settled
                    else:
                        # Play "good" sound to signal "stop moving marker"
                        if soundOption:
                            time.sleep(0.2)
                            winsound.Beep(1200, 200)
                            winsound.Beep(1200, 200)
                            time.sleep(0.2)
                        else:
                            self.engine.say("Stop there")
                            self.engine.runAndWait()
                            time.sleep(self.speechPause)
                
                # Still within distance of effect
                elif minDistToPt < self.maxDist:
                    if soundOption:
                        freq = int(self.freqIntercept + self.freqSlope * \
                            minDistToPt)
                        winsound.Beep(freq, self.duration)
                    else:
                        diffPt = intPt - self.regEd.viconListener.\
                            movingPoses[minPtIdx]
                        self.engine.say(self.speechFormat % \
                            (diffPt.x, diffPt.y))
                        self.engine.runAndWait()
                        time.sleep(self.speechPause)

    def stop(self):
        """Signal for the thread to end."""
        self.engine.stop()
        self.close.set()


if __name__ == "__main__":
    app = wx.PySimpleApp(0)
    wx.InitAllImageHandlers()
    if len(sys.argv) > 1:
        regEd = regionEditor(None, -1, sys.argv[1])
    else:
        regEd = regionEditor(None, -1)
    app.SetTopWindow(regEd)
    app.MainLoop()
